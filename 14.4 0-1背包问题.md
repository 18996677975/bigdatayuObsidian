```ad-question
title: 0-1背包问题
给定 𝑛 个物品，第 𝑖 个物品的重量为 𝑤𝑔𝑡[𝑖−1]、价值为 𝑣𝑎𝑙[𝑖−1] ，和一个容量为 𝑐𝑎𝑝 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

```
物品编号 𝑖 从 1 开始计数，数组索引从 0 开始计数，因此物品 𝑖 对应重量 𝑤𝑔𝑡[𝑖−1] 和价值 𝑣𝑎𝑙[𝑖−1] 。
![[Pasted image 20240610103226.png]]
可以将 0-1 背包问题看作一个由 𝑛 轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此该问题满足决策树模型。
该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题。

**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 𝑖 和背包容量 𝑐 ，记为 [𝑖,𝑐] 。
状态 [𝑖,𝑐] 对应的子问题为：**前 𝑖 个物品在容量为 𝑐 的背包中的最大价值**，记为 𝑑𝑝[𝑖,𝑐] 。
待求解的是 𝑑𝑝[𝑛,𝑐𝑎𝑝] ，因此需要一个尺寸为 (𝑛+1)×(𝑐𝑎𝑝+1) 的二维 𝑑𝑝 表。

**第二步：找出最优子结构，进而推导出状态转移方程**
当我们做出物品 𝑖 的决策后，剩余的是前 𝑖−1 个物品决策的子问题，可分为以下两种情况。
- **不放入物品 𝑖** ：背包容量不变，状态变化为 [𝑖−1,𝑐] 。
- **放入物品 𝑖** ：背包容量减少 𝑤𝑔𝑡[𝑖−1] ，价值增加 𝑣𝑎𝑙[𝑖−1] ，状态变化为 [𝑖−1,𝑐−𝑤𝑔𝑡[𝑖−1]] 。
上述分析向我们揭示了本题的最优子结构：**最大价值 𝑑𝑝[𝑖,𝑐] 等于不放入物品 𝑖 和放入物品 𝑖 两种方案中价值更大的那一个**。由此可推导出状态转移方程：
![[Pasted image 20240610103700.png]]
需要注意的是，若当前物品重量 𝑤𝑔𝑡[𝑖−1] 超出剩余背包容量 𝑐 ，则只能选择不放入背包。

**第三步：确定边界条件和状态转移顺序**
当无物品或背包容量为 0 时最大价值为 0 ，即首列 𝑑𝑝[𝑖,0] 和首行 𝑑𝑝[0,𝑐] 都等于 0 。
当前状态 [𝑖,𝑐] 从上方的状态 [𝑖−1,𝑐] 和左上方的状态 [𝑖−1,𝑐−𝑤𝑔𝑡[𝑖−1]] 转移而来，因此通过两层循环正序遍历整个 𝑑𝑝 表即可。
根据以上分析，我们接下来按顺序实现暴力搜索、记忆化搜索、动态规划解法。

### 1. 方法一：暴力搜索
搜索代码包含以下要素。
- **递归参数**：状态 [𝑖,𝑐] 。
- **返回值**：子问题的解 𝑑𝑝[𝑖,𝑐] 。
- **终止条件**：当物品编号越界 𝑖=0 或背包剩余容量为 0 时，终止递归并返回价值 0 。
- **剪枝**：若当前物品重量超出背包剩余容量，则只能选择不放入背包。
```python
def knapsack_dfs(wgt: list[int], val: list[int], i: int, c: int) -> int:
	"""0-1 背包：暴力搜索"""
	# 若已选完所有物品或背包无剩余容量，则返回价值 0
	if i == 0 or c == 0:
	    return 0
	# 若超过背包容量，则只能选择不放入背包
	if wgt[i - 1] > c:
	    return knapsack_dfs(wgt, val, i - 1, c)
	# 计算不放入和放入物品 i 的最大价值
	no = knapsack_dfs(wgt, val, i - 1, c)
	yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]
	# 返回两种方案中价值更大的那一个
	return max(no, yes)
```