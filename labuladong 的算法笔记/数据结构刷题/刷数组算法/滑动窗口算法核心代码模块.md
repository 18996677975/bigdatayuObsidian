| LeetCode                                                                                                                                             | 力扣                                                                                                                                   | 难度  |
| ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | --- |
| [3. Longest Substring Without Repeating Charactersopen in new window](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | [3. 无重复字符的最长子串open in new window](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)                      | 🟠  |
| [438. Find All Anagrams in a Stringopen in new window](https://leetcode.com/problems/find-all-anagrams-in-a-string/)                                 | [438. 找到字符串中所有字母异位词open in new window](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)                                  | 🟠  |
| [567. Permutation in Stringopen in new window](https://leetcode.com/problems/permutation-in-string/)                                                 | [567. 字符串的排列open in new window](https://leetcode.cn/problems/permutation-in-string/)                                                 | 🟠  |
| [76. Minimum Window Substringopen in new window](https://leetcode.com/problems/minimum-window-substring/)                                            | [76. 最小覆盖子串open in new window](https://leetcode.cn/problems/minimum-window-substring/)                                               | 🔴  |
| -                                                                                                                                                    | [剑指 Offer 48. 最长不含重复字符的子字符串open in new window](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) | 🟠  |
| -                                                                                                                                                    | [剑指 Offer II 014. 字符串中的变位词open in new window](https://leetcode.cn/problems/MPnaiL/)                                                  | 🟠  |
| -                                                                                                                                                    | [剑指 Offer II 015. 字符串中的所有变位词open in new window](https://leetcode.cn/problems/VabMRr/)                                                | 🟠  |
| -                                                                                                                                                    | [剑指 Offer II 016. 不含重复字符的最长子字符串open in new window](https://leetcode.cn/problems/wtcaE1/)                                             | 🟠  |
| -                                                                                                                                                    | [剑指 Offer II 017. 含有所有字符的最短字符串open in new window](https://leetcode.cn/problems/M1oyTv/)                                              | 🔴  |

### 滑动窗口框架概览
**滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组**。
如果用暴力解的话，你需要嵌套 for 循环这样穷举所有子数组，时间复杂度是 `O(N^2)`：
```C++
for (int i = 0; i < nums.size(); i++) {
    for (int j = i; j < nums.size(); j++) {
        // nums[i, j] 是一个子数组
    }
}
```
滑动窗口算法技巧的思路也不难，就是维护一个窗口，不断滑动，然后更新答案，该算法的大致逻辑如下：
```C++
int left = 0, right = 0;

while (right < nums.size()) {
    // 增大窗口
    window.add(nums[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(nums[left]);
        left++;
    }
}
```
基于滑动窗口算法框架写出的代码，时间复杂度是 `O(N)`，比嵌套 for 循环的暴力解法效率高。

滑动窗口模板：
```python
# 滑动窗口算法框架
def slidingWindow(s: str):
    # 用合适的数据结构记录窗口中的数据，根据具体场景变通
    # 比如说，我想记录窗口中元素出现的次数，就用 map
    # 我想记录窗口中的元素和，就用 int
    window = dict()
    
    left = 0
    right = 0
    while right < len(s):
        # c 是将移入窗口的字符
        c = s[right]
        window[c] = window.get(c, 0) + 1
        # 增大窗口
        right += 1
        # 进行窗口内数据的一系列更新
        #...

        #/*** debug 输出的位置 ***/
        # 注意在最终的解法代码中不要 print
        # 因为 IO 操作很耗时，可能导致超时
        # print(f"window: [{left}, {right})")
        #/********************/

        # 判断左侧窗口是否要收缩
        while left < right and "window needs shrink":
            # d 是将移出窗口的字符
            d = s[left]
            window[d] -= 1
            if window[d] == 0:
                del window[d]
            # 缩小窗口
            left += 1
            # 进行窗口内数据的一系列更新
            #...
```