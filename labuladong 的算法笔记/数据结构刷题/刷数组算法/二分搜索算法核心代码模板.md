| LeetCode                                                                                                                                                                | 力扣                                                                                                                                   | 难度  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | --- |
| [34. Find First and Last Position of Element in Sorted Arrayopen in new window](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [34. 在排序数组中查找元素的第一个和最后一个位置open in new window](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | 🟠  |
| [704. Binary Searchopen in new window](https://leetcode.com/problems/binary-search/)                                                                                    | [704. 二分查找open in new window](https://leetcode.cn/problems/binary-search/)                                                           | 🟢  |
| -                                                                                                                                                                       | [剑指 Offer 53 - I. 在排序数组中查找数字 Iopen in new window](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)        | 🟢  |

### 一、二分查找框架
```python

# 二分查找
def binarySearch(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```
**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。
**另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

### 二、寻找一个数（基本的二分搜索）
这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。704 题「 [二分查找open in new window](https://leetcode.cn/problems/binary-search/) 」。
```python
class Solution:  
    def search(self, nums: List[int], target: int) -> int:  
        left, right = 0, len(nums) - 1  
  
        while left <= right:  
            mid = left + (right - left) // 2  
            if nums[mid] == target:  
                return mid  
            elif nums[mid] > target:  
                right = mid - 1  
            elif nums[mid] < target:  
                left = mid + 1  
  
        return -1
```

### 三、寻找左侧边界的二分搜索
