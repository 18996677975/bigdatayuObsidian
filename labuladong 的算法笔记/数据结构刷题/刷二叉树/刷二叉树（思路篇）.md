
| LeetCode                                                                                                                                         | 力扣                                                                                                                   | 难度  |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- | --- |
| [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)                   | [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)                  | 🟠  |
| [116. Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) | [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) | 🟠  |
| [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)                                                   | [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)                                     | 🟢  |
| -                                                                                                                                                | [剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)                 | 🟢  |

本文承接 [[刷二叉树（纲领篇）]] ,复述一下前文总结的二叉树解题总纲：
```ad-note
title: 二叉树解题总纲
二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。


无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

```

### 翻转二叉树
226 题「 [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) 」，输入一个二叉树根节点 `root`，让你把整棵树镜像翻转，比如输入的二叉树如下：
```txt
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
算法原地翻转二叉树，使得以 `root` 为根的树变成：
```txt
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
不难发现，只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。

**1、「遍历」的思维模式**
`traverse` 函数遍历每个节点，让每个节点的左右子节点颠倒过来就行了。
```python
"""  
遍历的方式  
"""  
class Solution:  
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:  
        self.traverse(root)  
        return root  
  
    def traverse(self, root):  
        if not root:  
            return  
  
        leftNode, rightNode = root.left, root.right  
        root.left = rightNode  
        root.right = leftNode  
  
        self.traverse(root.left)  
        self.traverse(root.right)
```

**2、「分解问题」的思维模式**
给 `invertTree` 函数赋予一个定义：
```python
# 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
def invertTree(root: TreeNode) -> TreeNode:
```
对于某一个二叉树节点 `x` 执行 `invertTree(x)`，可以用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。
```python
"""  
分解问题的方式  
"""  
class Solution:  
    # 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点  
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:  
        if not root:  
            return None  
  
        leftTree = self.invertTree(root.left)  
        rightTree = self.invertTree(root.right)  
  
        root.left = rightTree  
        root.right = leftTree  
  
        return root
```

### 填充节点的右侧指针
116 题「 [填充每个二叉树节点的右侧指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 」


### 将二叉树展开为链表
114 题「[将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)」