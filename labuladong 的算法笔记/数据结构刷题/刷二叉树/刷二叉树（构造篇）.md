| LeetCode                                                                                                                                                       | åŠ›æ‰£                                                                                                               | éš¾åº¦  |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | --- |
| [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)     | [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)  | ğŸŸ   |
| [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)   | [106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | ğŸŸ   |
| [654. Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)                                                                                 | [654. æœ€å¤§äºŒå‰æ ‘](https://leetcode.cn/problems/maximum-binary-tree/)                                                  | ğŸŸ   |
| [889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) | [889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) | ğŸŸ   |
| -                                                                                                                                                              | [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)                                   | ğŸŸ   |

æ‰¿æ¥Â [[ä¸œå“¥å¸¦ä½ åˆ·äºŒå‰æ ‘ï¼ˆçº²é¢†ç¯‡ï¼‰]] çš„ç¬¬äºŒç¯‡æ–‡ç« ï¼Œå…ˆå¤è¿°ä¸€ä¸‹å‰æ–‡æ€»ç»“çš„äºŒå‰æ ‘è§£é¢˜æ€»çº²ï¼š
```ad-note
title: æ³¨
äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š

**1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ªÂ `traverse`Â å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚

**2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚

æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½éœ€è¦æ€è€ƒï¼š

**å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åš**ï¼Ÿå…¶ä»–çš„èŠ‚ç‚¹ä¸ç”¨ä½ æ“å¿ƒï¼Œé€’å½’å‡½æ•°ä¼šå¸®ä½ åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šæ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚
```

**äºŒå‰æ ‘çš„æ„é€ é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯ï¼šæ„é€ æ•´æ£µæ ‘ = æ ¹èŠ‚ç‚¹ + æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘**ã€‚

### æ„é€ æœ€å¤§äºŒå‰æ ‘
Â 654 é¢˜ã€Œ[æœ€å¤§äºŒå‰æ ‘](https://leetcode.cn/problems/maximum-binary-tree/)ã€
```ad-question
title: 654. æœ€å¤§äºŒå‰æ ‘
ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„Â `nums`Â ã€‚Â **æœ€å¤§äºŒå‰æ ‘**Â å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä»Â `nums`Â é€’å½’åœ°æ„å»º:
1. åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸ºÂ `nums`Â ä¸­çš„æœ€å¤§å€¼ã€‚
2. é€’å½’åœ°åœ¨æœ€å¤§å€¼Â **å·¦è¾¹**Â çš„Â **å­æ•°ç»„å‰ç¼€ä¸Š**Â æ„å»ºå·¦å­æ ‘ã€‚
3. é€’å½’åœ°åœ¨æœ€å¤§å€¼Â **å³è¾¹**Â çš„Â **å­æ•°ç»„åç¼€ä¸Š**Â æ„å»ºå³å­æ ‘ã€‚

è¿”å›Â _`nums`Â æ„å»ºçš„_Â **_æœ€å¤§äºŒå‰æ ‘_**Â ã€‚

**ç¤ºä¾‹ 1ï¼š**
![[Pasted image 20240621174851.png]]
**è¾“å…¥ï¼š**nums = [3,2,1,6,0,5]
**è¾“å‡ºï¼š**[6,3,5,null,2,0,null,null,1]
**è§£é‡Šï¼š**é€’å½’è°ƒç”¨å¦‚ä¸‹æ‰€ç¤ºï¼š
- [3,2,1,6,0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 6 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [3,2,1] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [0,5] ã€‚
    - [3,2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 3 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [2,1] ã€‚
        - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
        - [2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 2 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [1] ã€‚
            - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
            - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 1 çš„èŠ‚ç‚¹ã€‚
    - [0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 5 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [0] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [] ã€‚
        - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 0 çš„èŠ‚ç‚¹ã€‚
        - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 2ï¼š**
![[Pasted image 20240621174912.png]]
**è¾“å…¥ï¼š**nums = [3,2,1]
**è¾“å‡ºï¼š**[3,null,2,null,1]

**æç¤ºï¼š**
- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums`Â ä¸­çš„æ‰€æœ‰æ•´æ•°Â **äº’ä¸ç›¸åŒ**

```
å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š
```python
def constructMaximumBinaryTree(nums: List[int]) -> Optional[TreeNode]:
```
æ¯ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹éƒ½å¯ä»¥è®¤ä¸ºæ˜¯ä¸€æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¯¹äºæ ¹èŠ‚ç‚¹ï¼Œé¦–å…ˆè¦åšçš„å½“ç„¶æ˜¯æŠŠæƒ³åŠæ³•æŠŠè‡ªå·±å…ˆæ„é€ å‡ºæ¥ï¼Œç„¶åæƒ³åŠæ³•æ„é€ è‡ªå·±çš„å·¦å³å­æ ‘ã€‚

æ‰€ä»¥ï¼Œæˆ‘ä»¬è¦éå†æ•°ç»„æŠŠæ‰¾åˆ°æœ€å¤§å€¼Â `maxVal`ï¼Œä»è€ŒæŠŠæ ¹èŠ‚ç‚¹Â `root`Â åšå‡ºæ¥ï¼Œç„¶åå¯¹Â `maxVal`Â å·¦è¾¹çš„æ•°ç»„å’Œå³è¾¹çš„æ•°ç»„è¿›è¡Œé€’å½’æ„å»ºï¼Œä½œä¸ºÂ `root`Â çš„å·¦å³å­æ ‘ã€‚

æŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„ä¾‹å­ï¼Œè¾“å…¥çš„æ•°ç»„ä¸ºÂ `[3,2,1,6,0,5]`ï¼Œå¯¹äºæ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹æ¥è¯´ï¼Œå…¶å®åœ¨åšè¿™ä»¶äº‹ï¼š
```python
def constructMaximumBinaryTree(nums: List[int]) -> TreeNode:
    if not nums:
        return None

    # æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼åŠå…¶ç´¢å¼•
    max_num = max(nums)
    max_idx = nums.index(max_num)

    # ä»¥æœ€å¤§å€¼æ„é€ æ ¹èŠ‚ç‚¹
    root = TreeNode(max_num)

    # é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘
    root.left = constructMaximumBinaryTree(nums[:max_idx])
    root.right = constructMaximumBinaryTree(nums[max_idx+1:])

    return root
```
**å½“å‰Â `nums`Â ä¸­çš„æœ€å¤§å€¼å°±æ˜¯æ ¹èŠ‚ç‚¹ï¼Œç„¶åæ ¹æ®ç´¢å¼•é€’å½’è°ƒç”¨å·¦å³æ•°ç»„æ„é€ å·¦å³å­æ ‘å³å¯**ã€‚

æ˜ç¡®äº†æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°Â `build`ï¼Œæ¥æ§åˆ¶Â `nums`Â çš„ç´¢å¼•ï¼š
```python
# ä¸»å‡½æ•°
def constructMaximumBinaryTree(nums: List[int]) -> TreeNode:
    return build(nums, 0, len(nums) - 1)

# å®šä¹‰ï¼šå°† nums[lo..hi] æ„é€ æˆç¬¦åˆæ¡ä»¶çš„æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹
def build(nums: List[int], lo: int, hi: int) -> TreeNode:
    # base case
    if lo > hi:
        return None

    # æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•
    index, maxVal = -1, -sys.maxsize
    for i in range(lo, hi+1):
        if maxVal < nums[i]:
            index = i
            maxVal = nums[i]

    # å…ˆæ„é€ å‡ºæ ¹èŠ‚ç‚¹
    root = TreeNode(maxVal)
    # é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘
    root.left = build(nums, lo, index - 1)
    root.right = build(nums, index + 1, hi)
    
    return root
```

### é€šè¿‡å‰åºå’Œä¸­åºéå†ç»“æœæ„é€ äºŒå‰æ ‘
105 é¢˜ã€Œ [ä»å‰åºå’Œä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) ã€å°±æ˜¯è¿™é“ç»å…¸é¢˜ç›®ï¼Œé¢è¯•ç¬”è¯•ä¸­å¸¸è€ƒï¼š
```ad-question
title: 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„Â `preorder`Â å’ŒÂ `inorder`Â ï¼Œå…¶ä¸­Â `preorder`Â æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†**ï¼ŒÂ `inorder`Â æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†**ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1:**
![[Pasted image 20240621181441.png]]
**è¾“å…¥****:** preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
**è¾“å‡º:** [3,9,20,null,null,15,7]

**ç¤ºä¾‹ 2:**
**è¾“å…¥:** preorder = [-1], inorder = [-1]
**è¾“å‡º:** [-1]

**æç¤º:**
- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder`Â å’ŒÂ `inorder`Â å‡Â **æ— é‡å¤**Â å…ƒç´ 
- `inorder`Â å‡å‡ºç°åœ¨Â `preorder`
- `preorder`Â **ä¿è¯**Â ä¸ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—
- `inorder`Â **ä¿è¯**Â ä¸ºäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—

```
å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š
```python
def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:
```
åºŸè¯ä¸å¤šè¯´ï¼Œç›´æ¥æ¥æƒ³æ€è·¯ï¼Œé¦–å…ˆæ€è€ƒï¼Œæ ¹èŠ‚ç‚¹åº”è¯¥åšä»€ä¹ˆã€‚

**ç±»ä¼¼ä¸Šä¸€é¢˜ï¼Œæˆ‘ä»¬è‚¯å®šè¦æƒ³åŠæ³•ç¡®å®šæ ¹èŠ‚ç‚¹çš„å€¼ï¼ŒæŠŠæ ¹èŠ‚ç‚¹åšå‡ºæ¥ï¼Œç„¶åé€’å½’æ„é€ å·¦å³å­æ ‘å³å¯**ã€‚

æˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹ï¼Œå‰åºéå†å’Œä¸­åºéå†çš„ç»“æœæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ
```python
def traverse_preorder(root: TreeNode):
    # å‰åºéå†
    preorder.append(root.val)
    traverse_preorder(root.left)
    traverse_preorder(root.right)

def traverse_inorder(root: TreeNode):
    traverse_inorder(root.left)
    # ä¸­åºéå†
    inorder.append(root.val)
    traverse_inorder(root.right)
```
åæ–‡Â [äºŒå‰æ ‘å°±é‚£å‡ ä¸ªæ¡†æ¶](https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/)Â å†™è¿‡ï¼Œè¿™æ ·çš„éå†é¡ºåºå·®å¼‚ï¼Œå¯¼è‡´äº†Â `preorder`Â å’ŒÂ `inorder`Â æ•°ç»„ä¸­çš„å…ƒç´ åˆ†å¸ƒæœ‰å¦‚ä¸‹ç‰¹ç‚¹ï¼š
![[Pasted image 20240621181625.png|600]]
æ‰¾åˆ°æ ¹èŠ‚ç‚¹æ˜¯å¾ˆç®€å•çš„ï¼Œå‰åºéå†çš„ç¬¬ä¸€ä¸ªå€¼Â `preorder[0]`Â å°±æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ã€‚

å…³é”®åœ¨äºå¦‚ä½•é€šè¿‡æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå°†Â `preorder`Â å’ŒÂ `inorder`Â æ•°ç»„åˆ’åˆ†æˆä¸¤åŠï¼Œæ„é€ æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Ÿ

æ¢å¥è¯è¯´ï¼Œå¯¹äºä»¥ä¸‹ä»£ç ä¸­çš„Â `?`Â éƒ¨åˆ†åº”è¯¥å¡«å…¥ä»€ä¹ˆï¼š
```python
# ä¸»å‡½æ•°
def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:
    # æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œç”¨ preorder å’Œ inorder æ„é€ äºŒå‰æ ‘
    return build(preorder, 0, len(preorder)-1, inorder, 0, len(inorder)-1)

# build å‡½æ•°çš„å®šä¹‰ï¼šè‹¥å‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œæ„é€ äºŒå‰æ ‘ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
def build(preorder: List[int], preStart: int, preEnd: int, inorder: List[int], inStart: int, inEnd: int) -> TreeNode:
    # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    rootVal = preorder[preStart]
    # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index = 0
    for i in range(inStart, inEnd+1):
        if inorder[i] == rootVal:
            index = i
            break

    root = TreeNode(rootVal)
    # é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(preorder, preStart+1, preStart+(index-inStart),
                      inorder, inStart, index-1)

    root.right = build(preorder, preStart+(index-inStart)+1, preEnd,
                       inorder, index+1, inEnd)
    return root
```
å¯¹äºä»£ç ä¸­çš„Â `rootVal`Â å’ŒÂ `index`Â å˜é‡ï¼Œå°±æ˜¯ä¸‹å›¾è¿™ç§æƒ…å†µï¼š
![[Pasted image 20240704143043.png]]

å¦å¤–ï¼Œä¹Ÿæœ‰è¯»è€…æ³¨æ„åˆ°ï¼Œé€šè¿‡ for å¾ªç¯éå†çš„æ–¹å¼å»ç¡®å®šÂ `index`Â æ•ˆç‡ä¸ç®—é«˜ï¼Œå¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚

å› ä¸ºé¢˜ç›®è¯´äºŒå‰æ ‘èŠ‚ç‚¹çš„å€¼ä¸å­˜åœ¨é‡å¤ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸€ä¸ª HashMap å­˜å‚¨å…ƒç´ åˆ°ç´¢å¼•çš„æ˜ å°„ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥é€šè¿‡ HashMap æŸ¥åˆ°Â `rootVal`Â å¯¹åº”çš„Â `index`ï¼š
```python
from typing import List
# å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
valToIndex = {}

def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:
    for i in range(len(inorder)):
        valToIndex[inorder[i]] = i
    return build(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)

def build(preorder: List[int], preStart: int, preEnd: int, 
          inorder: List[int], inStart: int, inEnd: int) -> TreeNode:
    rootVal = preorder[preStart]
    # é¿å… for å¾ªç¯å¯»æ‰¾ rootVal
    index = valToIndex[rootVal]
    # ...
```
ç°åœ¨æˆ‘ä»¬æ¥çœ‹å›¾åšå¡«ç©ºé¢˜ï¼Œä¸‹é¢è¿™å‡ ä¸ªé—®å·å¤„åº”è¯¥å¡«ä»€ä¹ˆï¼š
```python
root.left = build(preorder, ??, ??,
                  inorder, ??, ??)

root.right = build(preorder, ??, ??,
                   inorder, ??, ??)
```
å¯¹äºå·¦å³å­æ ‘å¯¹åº”çš„Â `inorder`Â æ•°ç»„çš„èµ·å§‹ç´¢å¼•å’Œç»ˆæ­¢ç´¢å¼•æ¯”è¾ƒå®¹æ˜“ç¡®å®šï¼š
![[Pasted image 20240704143501.png]]

```python
root.left = build(preorder, ?, ?,
                  inorder, inStart, index - 1)

root.right = build(preorder, ?, ?,
                   inorder, index + 1, inEnd)
```

å¯¹äºÂ `preorder`Â æ•°ç»„å‘¢ï¼Ÿå¦‚ä½•ç¡®å®šå·¦å³æ•°ç»„å¯¹åº”çš„èµ·å§‹ç´¢å¼•å’Œç»ˆæ­¢ç´¢å¼•ï¼Ÿ

è¿™ä¸ªå¯ä»¥é€šè¿‡å·¦å­æ ‘çš„èŠ‚ç‚¹æ•°æ¨å¯¼å‡ºæ¥ï¼Œå‡è®¾å·¦å­æ ‘çš„èŠ‚ç‚¹æ•°ä¸ºÂ `leftSize`ï¼Œé‚£ä¹ˆÂ `preorder`Â æ•°ç»„ä¸Šçš„ç´¢å¼•æƒ…å†µæ˜¯è¿™æ ·çš„ï¼š
![[Pasted image 20240704143612.png]]

çœ‹ç€è¿™ä¸ªå›¾å°±å¯ä»¥æŠŠÂ `preorder`Â å¯¹åº”çš„ç´¢å¼•å†™è¿›å»äº†ï¼š
```python
leftSize = index - inStart

root.left = build(preorder, preStart + 1, preStart + leftSize,
                  inorder, inStart, index - 1)

root.right = build(preorder, preStart + leftSize + 1, preEnd,
                   inorder, index + 1, inEnd)
```
è‡³æ­¤ï¼Œæ•´ä¸ªç®—æ³•æ€è·¯å°±å®Œæˆäº†ï¼Œæˆ‘ä»¬å†è¡¥ä¸€è¡¥ base case å³å¯å†™å‡ºè§£æ³•ä»£ç ï¼š
```python
def build(preorder: List[int], preStart: int, preEnd: int, inorder: List[int], inStart: int, inEnd: int) -> TreeNode:
        
    if preStart > preEnd:
        return None

    # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    rootVal = preorder[preStart]
    # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index = valToIndex.get(rootVal)

    leftSize = index - inStart

    # å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    root = TreeNode(rootVal) 



    # é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1)

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd)
    return root
```
æˆ‘ä»¬çš„ä¸»å‡½æ•°åªè¦è°ƒç”¨Â `build`Â å‡½æ•°å³å¯ï¼Œä½ çœ‹ç€å‡½æ•°è¿™ä¹ˆå¤šå‚æ•°ï¼Œè§£æ³•è¿™ä¹ˆå¤šä»£ç ï¼Œä¼¼ä¹æ¯”æˆ‘ä»¬ä¸Šé¢è®²çš„é‚£é“é¢˜éš¾å¾ˆå¤šï¼Œè®©äººæœ›è€Œç”Ÿç•ï¼Œå®é™…ä¸Šå‘¢ï¼Œè¿™äº›å‚æ•°æ— éå°±æ˜¯æ§åˆ¶æ•°ç»„èµ·æ­¢ä½ç½®çš„ï¼Œç”»ä¸ªå›¾å°±èƒ½è§£å†³äº†ã€‚

### é€šè¿‡ååºå’Œä¸­åºéå†ç»“æœæ„é€ äºŒå‰æ ‘
ç±»ä¼¼ä¸Šä¸€é¢˜ï¼Œè¿™æ¬¡æˆ‘ä»¬åˆ©ç”¨**ååº**å’Œ**ä¸­åº**éå†çš„ç»“æœæ•°ç»„æ¥è¿˜åŸäºŒå‰æ ‘ï¼Œè¿™æ˜¯åŠ›æ‰£ç¬¬ 106 é¢˜ã€Œ [ä»ååºå’Œä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) ã€ã€‚

éå†é¡ºåºå·®å¼‚ï¼Œå¯¼è‡´äº†Â `postorder`Â å’ŒÂ `inorder`Â æ•°ç»„ä¸­çš„å…ƒç´ åˆ†å¸ƒæœ‰å¦‚ä¸‹ç‰¹ç‚¹ï¼š
![[Pasted image 20240704143902.png]]
è¿™é“é¢˜å’Œä¸Šä¸€é¢˜çš„å…³é”®åŒºåˆ«æ˜¯ï¼Œååºéå†å’Œå‰åºéå†ç›¸åï¼Œæ ¹èŠ‚ç‚¹å¯¹åº”çš„å€¼ä¸ºÂ `postorder`Â çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚

æ•´ä½“çš„ç®—æ³•æ¡†æ¶å’Œä¸Šä¸€é¢˜éå¸¸ç±»ä¼¼ï¼Œæˆ‘ä»¬ä¾ç„¶å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°Â `build`ï¼š
```python
# å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
val_to_index = dict()

def build_tree(inorder, postorder):
    for i in range(len(inorder)):
        val_to_index[inorder[i]] = i
    return build(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1)

# build å‡½æ•°çš„å®šä¹‰ï¼š
# ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
# ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
# æ„é€ äºŒå‰æ ‘ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ 
def build(inorder, inStart, inEnd, postorder, postStart, postEnd):
    # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    rootVal = postorder[postEnd]
    # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index = val_to_index[rootVal]

    root = TreeNode(rootVal)
    # é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + index - inStart - 1)
    root.right = build(inorder, index + 1, inEnd, postorder, postStart + index - inStart, postEnd - 1)
    
    return root
```
ç°åœ¨Â `postoder`Â å’ŒÂ `inorder`Â å¯¹åº”çš„çŠ¶æ€å¦‚ä¸‹ï¼š
![[Pasted image 20240704144208.png]]

æˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä¸Šå›¾å°†é—®å·å¤„çš„ç´¢å¼•æ­£ç¡®å¡«å…¥ï¼š
```python
leftSize = index - inStart

root.left = build(inorder, inStart, index - 1,
                  postorder, postStart, postStart + leftSize - 1)

root.right = build(inorder, index + 1, inEnd,
                   postorder, postStart + leftSize, postEnd - 1)
```

ç»¼ä¸Šï¼Œå¯ä»¥å†™å‡ºå®Œæ•´çš„è§£æ³•ä»£ç ï¼š
```python
class Solution:  
    def __init__(self):  
        self.valToIndex = {}  
  
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:  
        for i in range(len(inorder)):  
            self.valToIndex[inorder[i]] = i  
        return self.build(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1)  
  
    def build(self, inorder: List[int], inoStart: int, inoEnd: int, postorder: List[int], postStart: int, postEnd: int):  
        if postStart > postEnd:  
            return None  
  
        rootVal = postorder[postEnd]  
  
        index = self.valToIndex.get(rootVal)  
  
        leftSize = index - inoStart  
  
        root = TreeNode(rootVal)  
  
        root.left = self.build(inorder, inoStart, index - 1, postorder, postStart, postStart + leftSize - 1)  
        root.right = self.build(inorder, index + 1, inoEnd, postorder, postStart + leftSize, postEnd - 1)  
  
        return root
```

æœ‰äº†å‰ä¸€é¢˜çš„é“ºå«ï¼Œè¿™é“é¢˜å¾ˆå¿«å°±è§£å†³äº†ï¼Œæ— éå°±æ˜¯Â `rootVal`Â å˜æˆäº†æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå†æ”¹æ”¹é€’å½’å‡½æ•°çš„å‚æ•°è€Œå·²ï¼Œåªè¦æ˜ç™½äºŒå‰æ ‘çš„ç‰¹æ€§ï¼Œä¹Ÿä¸éš¾å†™å‡ºæ¥ã€‚

### é€šè¿‡ååºå’Œå‰åºéå†ç»“æœæ„é€ äºŒå‰æ ‘
è¿™æ˜¯åŠ›æ‰£ç¬¬ 889 é¢˜ã€Œ [æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) ã€ï¼Œç»™ä½ è¾“å…¥äºŒå‰æ ‘çš„å‰åºå’Œååºéå†ç»“æœï¼Œè®©ä½ è¿˜åŸäºŒå‰æ ‘çš„ç»“æ„ã€‚

è¿™é“é¢˜å’Œå‰ä¸¤é“é¢˜æœ‰ä¸€ä¸ªæœ¬è´¨çš„åŒºåˆ«ï¼š

**é€šè¿‡å‰åºä¸­åºï¼Œæˆ–è€…ååºä¸­åºéå†ç»“æœå¯ä»¥ç¡®å®šå”¯ä¸€ä¸€æ£µåŸå§‹äºŒå‰æ ‘ï¼Œä½†æ˜¯é€šè¿‡å‰åºååºéå†ç»“æœæ— æ³•ç¡®å®šå”¯ä¸€çš„åŸå§‹äºŒå‰æ ‘**ã€‚

é¢˜ç›®ä¹Ÿè¯´äº†ï¼Œå¦‚æœæœ‰å¤šç§å¯èƒ½çš„è¿˜åŸç»“æœï¼Œä½ å¯ä»¥è¿”å›ä»»æ„ä¸€ç§ã€‚

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬è¯´è¿‡ï¼Œæ„å»ºäºŒå‰æ ‘çš„å¥—è·¯å¾ˆç®€å•ï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åæ‰¾åˆ°å¹¶é€’å½’æ„é€ å·¦å³å­æ ‘å³å¯ã€‚

å‰ä¸¤é“é¢˜ï¼Œå¯ä»¥é€šè¿‡å‰åºæˆ–è€…ååºéå†ç»“æœæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åæ ¹æ®ä¸­åºéå†ç»“æœç¡®å®šå·¦å³å­æ ‘ï¼ˆé¢˜ç›®è¯´äº†æ ‘ä¸­æ²¡æœ‰Â `val`Â ç›¸åŒçš„èŠ‚ç‚¹ï¼‰ã€‚

è¿™é“é¢˜ï¼Œä½ å¯ä»¥ç¡®å®šæ ¹èŠ‚ç‚¹ï¼Œä½†æ˜¯æ— æ³•ç¡®åˆ‡çš„çŸ¥é“å·¦å³å­æ ‘æœ‰å“ªäº›èŠ‚ç‚¹ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚ç»™ä½ è¿™ä¸ªè¾“å…¥ï¼š
```python
preorder = [1,2,3], postorder = [3,2,1]
```
ä¸‹é¢è¿™ä¸¤æ£µæ ‘éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼Œä½†æ˜¾ç„¶å®ƒä»¬çš„ç»“æ„ä¸åŒï¼š
![[Pasted image 20240704145147.png]]

ä¸è¿‡è¯è¯´å›æ¥ï¼Œç”¨ååºéå†å’Œå‰åºéå†ç»“æœè¿˜åŸäºŒå‰æ ‘ï¼Œè§£æ³•é€»è¾‘ä¸Šå’Œå‰ä¸¤é“é¢˜å·®åˆ«ä¸å¤§ï¼Œä¹Ÿæ˜¯é€šè¿‡æ§åˆ¶å·¦å³å­æ ‘çš„ç´¢å¼•æ¥æ„å»ºï¼š

**1ã€é¦–å…ˆæŠŠå‰åºéå†ç»“æœçš„ç¬¬ä¸€ä¸ªå…ƒç´ æˆ–è€…ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ ç¡®å®šä¸ºæ ¹èŠ‚ç‚¹çš„å€¼**ã€‚

**2ã€ç„¶åæŠŠå‰åºéå†ç»“æœçš„ç¬¬äºŒä¸ªå…ƒç´ ä½œä¸ºå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼**ã€‚

**3ã€åœ¨ååºéå†ç»“æœä¸­å¯»æ‰¾å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä»è€Œç¡®å®šäº†å·¦å­æ ‘çš„ç´¢å¼•è¾¹ç•Œï¼Œè¿›è€Œç¡®å®šå³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œï¼Œé€’å½’æ„é€ å·¦å³å­æ ‘å³å¯**ã€‚

![[Pasted image 20240704145202.png]]

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š
```python
class Solution:  
    def __init__(self):  
        self.valToIndex = {}  
  
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:  
        for i in range(len(postorder)):  
            self.valToIndex[postorder[i]] = i  
        return self.build(preorder, 0, len(preorder) - 1, postorder, 0, len(postorder) - 1)  
  
    def build(self, preorder: List[int], preStart: int, preEnd: int, postorder: List[int], postStart: int, postEnd: int):  
        if preStart > preEnd:  
            return None  
        if preStart == preEnd:  
            return TreeNode(preorder[preStart])  
  
        # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´   
        rootVal = preorder[preStart]  
        # root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´   
        # é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹  
        # ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´  
        nextRootVal = preorder[preStart + 1]  
  
        index = self.valToIndex.get(nextRootVal)  
  
        leftSize = index - postStart + 1  
  
        root = TreeNode(rootVal)  
        root.left = self.build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index)  
        root.right = self.build(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1)  
  
        return root
```