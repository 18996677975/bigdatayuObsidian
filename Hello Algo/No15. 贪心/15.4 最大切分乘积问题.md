```ad-question
title: 最大切分乘积问题
给定一个正整数 𝑛 ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少，如图 15-13 所示。

```
![[Pasted image 20240610214725.png]]

假设我们将 𝑛 切分为 𝑚 个整数因子，其中第 𝑖 个因子记为 𝑛𝑖 ，即
![[Pasted image 20240610214815.png]]
本题的目标是求得所有整数因子的最大乘积，即
![[Pasted image 20240610214839.png]]
我们需要思考的是：切分数量 𝑚 应该多大，每个 𝑛𝑖 应该是多少？

### 1. 贪心策略确定
根据经验，两个整数的乘积往往比它们的加和更大。假设从 𝑛 中分出一个因子 2 ，则它们的乘积为 2(𝑛−2) 。我们将该乘积与 𝑛 作比较：
![[Pasted image 20240610214949.png]]
如图 15-14 所示，当 𝑛≥4 时，切分出一个 2 后乘积会变大，**这说明大于等于 4 的整数都应该被切分**。

**贪心策略一**：如果切分方案中包含 ≥4 的因子，那么它就应该被继续切分。最终的切分方案只应出现 1、2、3 这三种因子。
![[Pasted image 20240610215001.png]]
接下来思考哪个因子是最优的。在 1、2、3 这三个因子中，显然 1 是最差的，因为 1×(𝑛−1)<𝑛 恒成立，即切分出 1 反而会导致乘积减小。
如图 15-15 所示，当 𝑛=6 时，有 3×3>2×2×2 。**这意味着切分出 3 比切分出 2 更优**。

**贪心策略二**：在切分方案中，最多只应存在两个 2 。因为三个 2 总是可以替换为两个 3 ，从而获得更大的乘积。
![[Pasted image 20240610215233.png]]

综上所述，可推理出以下贪心策略。
1. 输入整数 𝑛 ，从其不断地切分出因子 3 ，直至余数为 0、1、2 。
2. 当余数为 0 时，代表 𝑛 是 3 的倍数，因此不做任何处理。
3. 当余数为 2 时，不继续划分，保留。
4. 当余数为 1 时，由于 2×2>1×3 ，因此应将最后一个 3 替换为 2 。

### 2. 代码实现
如图 15-16 所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到 3 的个数 𝑎 ，用取模运算得到余数 𝑏 ，此时有：
$$ n = 3a +b $$
请注意，对于 𝑛≤3 的边界情况，必须拆分出一个 1 ，乘积为 1×(𝑛−1) 。
```python
def max_product_cutting(n: int) -> int:
	"""最大切分乘积：贪心"""
	# 当 n <= 3 时，必须切分出一个 1
	if n <= 3:
	    return 1 * (n - 1)
	# 贪心地切分出 3 ，a 为 3 的个数，b 为余数
	a, b = n // 3, n % 3
	if b == 1:
	    # 当余数为 1 时，将一对 1 * 3 转化为 2 * 2
	    return int(math.pow(3, a - 1)) * 2 * 2
	if b == 2:
	    # 当余数为 2 时，不做处理
	    return int(math.pow(3, a)) * 2
	# 当余数为 0 时，不做处理
	return int(math.pow(3, a))
```
![[Pasted image 20240610215551.png]]
**时间复杂度取决于编程语言的幂运算的实现方法**。以 Python 为例，常用的幂计算函数有三种。
- 运算符 `**` 和函数 `pow()` 的时间复杂度均为 𝑂(log⁡⁡𝑎) 。
- 函数 `math.pow()` 内部调用 C 语言库的 `pow()` 函数，其执行浮点取幂，时间复杂度为 𝑂(1) 。

变量 𝑎 和 𝑏 使用常数大小的额外空间，**因此空间复杂度为 𝑂(1)** 。

### 3. 正确性证明
使用反证法，只分析 𝑛≥3 的情况。
1. **所有因子 ≤3** ：假设最优切分方案中存在 ≥4 的因子 𝑥 ，那么一定可以将其继续划分为 2(𝑥−2) ，从而获得更大的乘积。这与假设矛盾。
2. **切分方案不包含 1** ：假设最优切分方案中存在一个因子 1 ，那么它一定可以合并入另外一个因子中，以获得更大的乘积。这与假设矛盾。
3. **切分方案最多包含两个 2** ：假设最优切分方案中包含三个 2 ，那么一定可以替换为两个 3 ，乘积更大。这与假设矛盾。