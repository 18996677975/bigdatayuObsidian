程序中实现重复执行任务的两种基本的程序控制结构：迭代、递归。

## 2.2.1 迭代
迭代（iteration）是一种重复执行某个任务的控制结构。
在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

### 1. for 循环
**适合在预先知道迭代次数时使用**。

### 2. while 循环
**`while` 循环比 `for` 循环的自由度更高**。

**`for` 循环的代码更加紧凑，`while` 循环更加灵活**，两者都可以实现迭代结构。

### 3. 嵌套循环
在一个循环结构内嵌套另一个循环结构。

## 2.2.2 递归
递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。
1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，递归代码主要包含三个要素。
1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 1+2+⋯+𝑛 的计算：
```python
def recur(n: int) -> int:
	"""递归"""
	# 终止条件
	if n == 1:
	    return 1
	# 递：递归调用
	res = recur(n - 1)
	# 归：返回结果
	return n + res
```
![[Pasted image 20240602113134.png]]
虽然从计算角度看，迭代与递归可以得到相同的结果，**但它们代表了两种完全不同的思考和解决问题的范式**。
- **迭代**：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
- **递归**：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。
- **迭代**：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。
- **递归**：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。

### 1. 调用栈
递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。
- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。
如下图所示，在触发终止条件前，同时存在 𝑛 个未返回的递归函数，**递归深度为 𝑛** 。
![[Pasted image 20240602113219.png]]
在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。

### 2. 尾递归
**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。
- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 `res` 设为函数参数，从而实现尾递归：
```python
def tail_recur(n, res):
	"""尾递归"""
	# 终止条件
	if n == 0:
	    return res
	# 尾递归调用
	return tail_recur(n - 1, res + n)
```
对比普通递归和尾递归，两者的求和操作的执行点是不同的。
- **普通递归**：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
- **尾递归**：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。
![[Pasted image 20240602113344.png]]
### 3. 递归树
当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。
```ad-question
collapse: open
给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。

```
设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。
- 数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。
- 数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。

按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 `fib(n)` 即可得到斐波那契数列的第 𝑛 个数字：
```python
def fib(n: int) -> int:
	"""斐波那契数列：递归"""
	# 终止条件 f(1) = 0, f(2) = 1
	if n == 1 or n == 2:
	    return n - 1
	# 递归调用 f(n) = f(n-1) + f(n-2)
	res = fib(n - 1) + fib(n - 2)
	# 返回结果 f(n)
	return res
```
观察以上代码，我们在函数内递归调用了两个函数，**这意味着从一个调用产生了两个调用分支**。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。
![[Pasted image 20240602113626.png]]
从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。
- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。

## 2.2.3 对比
|          | 迭代                                   | 递归                                                         |     |
| -------- | -------------------------------------- | ------------------------------------------------------------ | --- |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |     |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |     |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |     | 
求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，**这种工作机制与栈的“先入后出”原则异曲同工**。

事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。
1. **递**：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。
2. **归**：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。

因此，**我们可以使用一个显式的栈来模拟调用栈的行为**，从而将递归转化为迭代形式：
```python
def for_loop_recur(n: int) -> int:
"""使用迭代模拟递归"""
# 使用一个显式的栈来模拟系统调用栈
stack = []
res = 0
# 递：递归调用
for i in range(n, 0, -1):
    # 通过“入栈操作”模拟“递”
    stack.append(i)
# 归：返回结果
while stack:
    # 通过“出栈操作”模拟“归”
    res += stack.pop()
# res = 1+2+3+...+n
return res
```
以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。
- 转化后的代码可能更加难以理解，可读性更差。
- 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。

总之，**选择迭代还是递归取决于特定问题的性质**。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。