## 8.2.1 借助入堆操作实现
首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。

每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。

设元素数量为 𝑛 ，每个元素的入堆操作使用 𝑂(log⁡𝑛) 时间，因此该建堆方法的时间复杂度为 𝑂(𝑛log⁡𝑛) 。

## 8.2.2 通过遍历堆化实现
更为高效的建堆方法：
1. 将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。
2. 倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。

**每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆**。而由于是倒序遍历，因此堆是“自下而上”构建的。倒序遍历保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。**由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化**。
```python
def __init__(self, nums: list[int]):
	"""构造方法，根据输入列表建堆"""
	# 将列表元素原封不动添加进堆
	self.max_heap = nums
	# 堆化除叶节点以外的其他所有节点
	for i in range(self.parent(self.size() - 1), -1, -1):
	    self.sift_down(i)
```

## 8.2.3 复杂度分析
第二种建堆方法的时间复杂度：**输入列表并建堆的时间复杂度为 𝑂(𝑛) ，非常高效**。