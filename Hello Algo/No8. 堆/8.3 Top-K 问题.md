## 8.3.1 遍历选择
𝑘 轮遍历，分别在每轮中提取第 1、2、…、𝑘 大的元素，时间复杂度为 𝑂(𝑛𝑘) 。当 𝑘 与 𝑛 比较接近时，其时间复杂度趋向于 𝑂(𝑛2) ，非常耗时。
![[Pasted image 20240603172026.png]]
## 8.3.2 排序
先对数组 `nums` 进行排序，再返回最右边的 𝑘 个元素，时间复杂度为 𝑂(𝑛log⁡𝑛) 。
![[Pasted image 20240603172113.png]]
## 8.3.3 堆
基于堆更加高效地解决 Top-k 问题：
1. 初始化一个小顶堆，其堆顶元素最小。
2. 先将数组的前 𝑘 个元素依次入堆。
3. 从第 𝑘+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。
4. 遍历完成后，堆中保存的就是最大的 𝑘 个元素。
```python
def top_k_heap(nums: list[int], k: int) -> list[int]:
	"""基于堆查找数组中最大的 k 个元素"""
	# 初始化小顶堆
	heap = []
	# 将数组的前 k 个元素入堆
	for i in range(k):
	    heapq.heappush(heap, nums[i])
	# 从第 k+1 个元素开始，保持堆的长度为 k
	for i in range(k, len(nums)):
	    # 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆
	    if nums[i] > heap[0]:
	        heapq.heappop(heap)
	        heapq.heappush(heap, nums[i])
	return heap
```

总共执行了 𝑛 轮入堆和出堆，堆的最大长度为 𝑘 ，因此时间复杂度为 𝑂(𝑛log⁡𝑘) 。该方法的效率很高，当 𝑘 较小时，时间复杂度趋向 𝑂(𝑛) ；当 𝑘 较大时，时间复杂度不会超过 𝑂(𝑛log⁡𝑛) 。
另外，该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大的 𝑘 个元素的动态更新。