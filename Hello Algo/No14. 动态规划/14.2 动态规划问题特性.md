在上一节中，我们学习了动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。
- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。

实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

## 14.2.1 最优子结构
```ad-question
title: 爬楼梯最小代价
给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 𝑐𝑜𝑠𝑡 ，其中 𝑐𝑜𝑠𝑡[𝑖] 表示在第 𝑖 个台阶需要付出的代价，𝑐𝑜𝑠𝑡[0] 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？

```
如图 14-6 所示，若第 1、2、3 阶的代价分别为 1、10、1 ，则从地面爬到第 3 阶的最小代价为 2 。
![[Pasted image 20240608221415.png]]
设 𝑑𝑝[𝑖] 为爬到第 𝑖 阶累计付出的代价，由于第 𝑖 阶只可能从 𝑖−1 阶或 𝑖−2 阶走来，因此 𝑑𝑝[𝑖] 只可能等于 𝑑𝑝[𝑖−1]+𝑐𝑜𝑠𝑡[𝑖] 或 𝑑𝑝[𝑖−2]+𝑐𝑜𝑠𝑡[𝑖] 。为了尽可能减少代价，我们应该选择两者中较小的那一个：
![[Pasted image 20240608222147.png]]
这便可以引出最优子结构的含义：**原问题的最优解是从子问题的最优解构建得来的**。

本题显然具有最优子结构：我们从两个子问题最优解 𝑑𝑝[𝑖−1] 和 𝑑𝑝[𝑖−2] 中挑选出较优的那一个，并用它构建出原问题 𝑑𝑝[𝑖] 的最优解。

那么，上一节的爬楼梯题目有没有最优子结构呢？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。我们意外地发现，**虽然题目修改前后是等价的，但最优子结构浮现出来了**：第 𝑛 阶最大方案数量等于第 𝑛−1 阶和第 𝑛−2 阶最大方案数量之和。所以说，最优子结构的解释方式比较灵活，在不同问题中会有不同的含义。

根据状态转移方程，以及初始状态 𝑑𝑝[1]=𝑐𝑜𝑠𝑡[1] 和 𝑑𝑝[2]=𝑐𝑜𝑠𝑡[2] ，我们就可以得到动态规划代码：