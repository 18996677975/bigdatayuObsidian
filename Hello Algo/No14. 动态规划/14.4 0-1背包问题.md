```ad-question
title: 0-1背包问题
给定 𝑛 个物品，第 𝑖 个物品的重量为 𝑤𝑔𝑡[𝑖−1]、价值为 𝑣𝑎𝑙[𝑖−1] ，和一个容量为 𝑐𝑎𝑝 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

```
物品编号 𝑖 从 1 开始计数，数组索引从 0 开始计数，因此物品 𝑖 对应重量 𝑤𝑔𝑡[𝑖−1] 和价值 𝑣𝑎𝑙[𝑖−1] 。
![[Pasted image 20240610103226.png]]
可以将 0-1 背包问题看作一个由 𝑛 轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此该问题满足决策树模型。
该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题。

**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 𝑖 和背包容量 𝑐 ，记为 [𝑖,𝑐] 。
状态 [𝑖,𝑐] 对应的子问题为：**前 𝑖 个物品在容量为 𝑐 的背包中的最大价值**，记为 𝑑𝑝[𝑖,𝑐] 。
待求解的是 𝑑𝑝[𝑛,𝑐𝑎𝑝] ，因此需要一个尺寸为 (𝑛+1)×(𝑐𝑎𝑝+1) 的二维 𝑑𝑝 表。

**第二步：找出最优子结构，进而推导出状态转移方程**
当我们做出物品 𝑖 的决策后，剩余的是前 𝑖−1 个物品决策的子问题，可分为以下两种情况。
- **不放入物品 𝑖** ：背包容量不变，状态变化为 [𝑖−1,𝑐] 。
- **放入物品 𝑖** ：背包容量减少 𝑤𝑔𝑡[𝑖−1] ，价值增加 𝑣𝑎𝑙[𝑖−1] ，状态变化为 [𝑖−1,𝑐−𝑤𝑔𝑡[𝑖−1]] 。
上述分析向我们揭示了本题的最优子结构：**最大价值 𝑑𝑝[𝑖,𝑐] 等于不放入物品 𝑖 和放入物品 𝑖 两种方案中价值更大的那一个**。由此可推导出状态转移方程：
![[Pasted image 20240610103700.png]]
需要注意的是，若当前物品重量 𝑤𝑔𝑡[𝑖−1] 超出剩余背包容量 𝑐 ，则只能选择不放入背包。

**第三步：确定边界条件和状态转移顺序**
当无物品或背包容量为 0 时最大价值为 0 ，即首列 𝑑𝑝[𝑖,0] 和首行 𝑑𝑝[0,𝑐] 都等于 0 。
当前状态 [𝑖,𝑐] 从上方的状态 [𝑖−1,𝑐] 和左上方的状态 [𝑖−1,𝑐−𝑤𝑔𝑡[𝑖−1]] 转移而来，因此通过两层循环正序遍历整个 𝑑𝑝 表即可。
根据以上分析，我们接下来按顺序实现暴力搜索、记忆化搜索、动态规划解法。

### 1. 方法一：暴力搜索
搜索代码包含以下要素。
- **递归参数**：状态 [𝑖,𝑐] 。
- **返回值**：子问题的解 𝑑𝑝[𝑖,𝑐] 。
- **终止条件**：当物品编号越界 𝑖=0 或背包剩余容量为 0 时，终止递归并返回价值 0 。
- **剪枝**：若当前物品重量超出背包剩余容量，则只能选择不放入背包。
```python
def knapsack_dfs(wgt: list[int], val: list[int], i: int, c: int) -> int:
	"""0-1 背包：暴力搜索"""
	# 若已选完所有物品或背包无剩余容量，则返回价值 0
	if i == 0 or c == 0:
	    return 0
	# 若超过背包容量，则只能选择不放入背包
	if wgt[i - 1] > c:
	    return knapsack_dfs(wgt, val, i - 1, c)
	# 计算不放入和放入物品 i 的最大价值
	no = knapsack_dfs(wgt, val, i - 1, c)
	yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]
	# 返回两种方案中价值更大的那一个
	return max(no, yes)
```
由于每个物品都会产生不选和选两条搜索分支，因此时间复杂度为 𝑂(2𝑛) 。
观察递归树，容易发现其中存在重叠子问题，例如 𝑑𝑝[1,10] 等。而当物品较多、背包容量较大，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多。
![[Pasted image 20240610104459.png]]

### 2. 方法二：记忆化搜索
为了保证重叠子问题只被计算一次，我们借助记忆列表 `mem` 来记录子问题的解，其中 `mem[i][c]` 对应 𝑑𝑝[𝑖,𝑐] 。
引入记忆化之后，**时间复杂度取决于子问题数量**，也就是 𝑂(𝑛×𝑐𝑎𝑝) 。实现代码如下：
```python
def knapsack_dfs_mem(
    wgt: list[int], val: list[int], mem: list[list[int]], i: int, c: int
) -> int:
    """0-1 背包：记忆化搜索"""
    # 若已选完所有物品或背包无剩余容量，则返回价值 0
    if i == 0 or c == 0:
        return 0
    # 若已有记录，则直接返回
    if mem[i][c] != -1:
        return mem[i][c]
    # 若超过背包容量，则只能选择不放入背包
    if wgt[i - 1] > c:
        return knapsack_dfs_mem(wgt, val, mem, i - 1, c)
    # 计算不放入和放入物品 i 的最大价值
    no = knapsack_dfs_mem(wgt, val, mem, i - 1, c)
    yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1]
    # 记录并返回两种方案中价值更大的那一个
    mem[i][c] = max(no, yes)
    return mem[i][c]
```
图 14-19 展示了在记忆化搜索中被剪掉的搜索分支。
![[Pasted image 20240610104757.png]]

### 3. 方法三：动态规划
动态规划实质上就是在状态转移中填充 𝑑𝑝 表的过程，代码如下所示：
```python
def knapsack_dp(wgt: list[int], val: list[int], cap: int) -> int:
	"""0-1 背包：动态规划"""
	n = len(wgt)
	# 初始化 dp 表
	dp = [[0] * (cap + 1) for _ in range(n + 1)]
	# 状态转移
	for i in range(1, n + 1):
	    for c in range(1, cap + 1):
	        if wgt[i - 1] > c:
	            # 若超过背包容量，则不选物品 i
	            dp[i][c] = dp[i - 1][c]
	        else:
	            # 不选和选物品 i 这两种方案的较大值
	            dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])
	return dp[n][cap]
```

### 4.  空间优化
由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从 𝑂(𝑛2) 降至 𝑂(𝑛) 。

进一步思考，我们能否仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第 𝑖 行时，该数组存储的仍然是第 𝑖−1 行的状态。
- 如果采取正序遍历，那么遍历到 𝑑𝑝[𝑖,𝑗] 时，左上方 𝑑𝑝[𝑖−1,1] ~ 𝑑𝑝[𝑖−1,𝑗−1] 值可能已经被覆盖，此时就无法得到正确的状态转移结果。
- 如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行。
```python
def knapsack_dp_comp(wgt: list[int], val: list[int], cap: int) -> int:
	"""0-1 背包：空间优化后的动态规划"""
	n = len(wgt)
	# 初始化 dp 表
	dp = [0] * (cap + 1)
	# 状态转移
	for i in range(1, n + 1):
	    # 倒序遍历
	    for c in range(cap, 0, -1):
	        if wgt[i - 1] > c:
	            # 若超过背包容量，则不选物品 i
	            dp[c] = dp[c]
	        else:
	            # 不选和选物品 i 这两种方案的较大值
	            dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])
	return dp[cap]
```

