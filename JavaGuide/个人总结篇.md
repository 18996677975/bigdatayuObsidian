# Java 基础
## JIT & AOT
 **JIT（Just in Time Compilation）** 编译器属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。
 ![[Pasted image 20240708213305.png]]

JDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。AOT 主要缺点在于无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。

## 基础类型与包装类型
- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- **比较方式**：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

Java 基本数据类型的包装类型使用缓存机制提升性能：`Byte`, `Short`, `Integer`, `Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。浮点数类型的包装类 `Float`, `Double` 并没有实现缓存机制。

**自动装箱与拆箱** 属于 **语法糖** 范畴：
- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型。

示例：
- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`

**频繁拆装箱会严重影响系统的性能，应避免不必要拆装箱操作。**

## 浮点数精度问题
浮点数存在精度丢失问题，与计算机保存浮点数的机制有关。计算机表示数字时，宽度有限，无限循环的小数存储在计算机时，只能被截断，因此导致小数精度发生损失的情况。

可通过 **`BigDecimal` 实现对浮点数的运算，不会造成精度丢失。**

用 `BigInteger` 可解决超过 long 整型的数据表示，它内部使用 `int[]` 数组来存储任意大小的整形数据，较常规数据类型运算效率更低。

## 重载与重写 ⭐
>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
\
 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

### 重载
发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。**

### 重写
重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

**方法的重写要遵循“两同两小一大”**：
- “两同” 即方法名相同、形参列表相同；
- “两小” 指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大” 指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

## 构造方法
构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。

构造方法特点：
- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

## 面向对象三特征 ⭐
### 封装
封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。可提供一些可以被外界访问的方法来操作属性（get、set）。
### 继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。（重写 @Override）

### 多态
多态，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

**多态的特点:**
- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用 “只在子类存在但在父类不存在” 的方法；
- 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 接口 & 抽象类
**共同点**：
- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别**：
- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但可以多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## 浅拷贝 & 深拷贝 & 引用拷贝
- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
- **引用拷贝**：两个不同的引用指向同一个对象。
![[Pasted image 20240625001148.png]]

## String & StringBuilder & StringBuffer
**可变性**
`String` 是不可变的。`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，`AbstractStringBuilder` 类提供了修改字符串的方法比如 `append` 方法。

**线程安全性**
`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，是线程安全的。`StringBuilder` 线程不安全。

**性能**
相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 能获得 10%~15% 左右的性能提升。

**使用总结**
- 操作少量的数据: 适用 `String`
- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

## Exception & Error
所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类：
- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`**：`Error` 属于程序无法处理的错误 ，不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

其中 **Exception** 又分为了 **Checked Exception** 与 **Unchecked Exception**：
- **Checked Exception** 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException` ……
- **Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中，我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常，常见的有：`NullPointerException` (空指针错误)、`IllegalArgumentException` (参数错误比如方法入参类型错误)、`NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException` 的子类）、`ArrayIndexOutOfBoundsException`（数组越界错误）……

##  `try-with-resources` 代替 `try-catch-finally`
`try-with-resources` 也是一种语法糖。

- **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象
- **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

`try-with-resources` 语句让我们更容易编写必须要关闭的资源的代码，更简短，更清晰，产生的异常对我们也更有用。

## Java 值传递
Java 中将实参传递给方法（或函数）的方式是 **值传递**：
- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 泛型 & 通配符 ⭐
### 泛型
泛型也是一种语法糖，于 Java 5 引入。使用泛型参数，可以 **增强代码的可读性以及稳定性**。编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。并且泛型可以让编译器自动转换类型。

泛型一般有三种使用方式：**泛型类**、**泛型接口**、**泛型方法**。
**1. 泛型类**：
```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```
如何实例化泛型类：
```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```
**2. 泛型接口**：
```java
public interface Generator<T> {
    public T method();
}
```
实现泛型接口，不指定类型：
```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```
实现泛型接口，指定类型：
```java
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```
**3. 泛型方法**：
```java
public static < E > void printArray( E[] inputArray )
{
      for ( E element : inputArray ){
         System.out.printf( "%s ", element );
      }
      System.out.println();
 }
```
使用：
```java
// 创建不同类型数组：Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray( intArray  );
printArray( stringArray  );
```

使用泛型的场景：
- 自定义接口通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）
- ……

**泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。对于 Java 虚拟机来说，他根本不认识 `Map<String, String> map` 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。

类型擦除的主要过程如下：1. 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2. 移除所有的类型参数。
以下代码：
```java
Map<String, String> map = new HashMap<String, String>();
```
解语法糖之后会变成：
```java
Map map = new HashMap();
```
以下代码：
```java
public static <A extends Comparable<A>> A max(Collection<A> xs) {
    Iterator<A> xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) < 0)
            w = x;
    }
    return w;
}
```
类型擦除后会变成：
```java
public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) < 0)
            w = x;
    }
    return w;
}
```

### 通配符
泛型通配符（Wildcard）是一种特殊的类型参数，用于表示未知类型或不确定类型。在 Java 中，有三种泛型通配符（分为限定通配符与非限定通配符）：
- `?`：表示任意类型。（非限定通配符）
- `? extends T`：表示某个类的子类或该类本身。（限定通配符）
- `? super T`：表示某个类的父类或该类本身。（限定通配符）

`<? extends T>` 它通过确保类型必须是 T 的子类来设定类型的上界，`<? super T>` 它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。

通过使用泛型通配符，我们可以编写更加灵活和通用的代码，使得方法能够接受多种类型的参数。

### 总结
泛型是 Java 中一种强大的特性，通过使用泛型，我们可以编写**更加通用、灵活和类型安全的代码**。**泛型通配符则进一步增强了代码的灵活性和重用性，使得方法能够接受多种类型的参数**。然而，过度使用泛型和通配符可能会导致代码复杂化，需要根据实际情况进行权衡和选择。

优点：
- 增强代码的可读性和可维护性：通过使用泛型和通配符，我们可以编写更加通用和灵活的代码，提高代码的重用性和可扩展性。
- 提供类型安全性：泛型在编译时进行类型检查，避免了运行时的类型转换异常，增强了代码的健壮性。
- 支持多态性：通过使用通配符，我们可以实现对不同类型的对象进行操作，提高了代码的灵活性和适应性。

缺点：
- 无法获取具体的泛型类型信息：由于类型擦除的原因，无法在运行时获取到具体的泛型类型信息，这可能会限制一些特定的操作。
- 可能导致代码复杂化：过度使用泛型和通配符可能会导致代码变得复杂难懂，增加了学习成本和调试困难。

注意事项：
- 在定义泛型方法时，可以使用 `<T>` 来表示类型参数。
- 使用通配符时，需要注意通配符的上限和下限，以确保代码的正确性和安全性。
- 需要根据具体的业务需求和场景选择合适的泛型和通配符使用方式。

## 反射 ⭐
Spring/Spring Boot、MyBatis 等框架大量使用了反射机制。**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。** **注解** 的实现也用到了反射。

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利，让我们在运行时有了分析操作类的能力。

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。

**反射实战**

获取 class 对象方法：
1. **知道具体类的情况下可使用**：`Class alunbarClass = TargetObject.class;`
2. **通过 `Class.forName()` 传入类的全路径获取：** `Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`
3. **通过对象实例 `instance.getClass()` 获取：** `TargetObject o = new TargetObject();Class alunbarClass2 = o.getClass();`
4. **通过类加载器 `xxxClassLoader.loadClass()` 传入类路径获取（类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行）：** `ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");`

然后通过如下方式进行操作：
1. **通过 `class.newInstance()` 创建实例：** `TargetObject targetObject = (TargetObject) targetClass.newInstance();`
2. **通过 `class.getDeclaredMethods()` 获取定义的方法：** `Method[] methods = targetClass.getDeclaredMethods();`
3. **通过 `class.getDeclaredMethod("publicMethod", String.class)` 获取特定方法：** `Method publicMethod = targetClass.getDeclaredMethod("publicMethod", String.class);`
4. **通过 `method.invoke(object, args)` 进行方法调用：** `publicMethod.invoke(targetObject, "JavaGuide");`
5. **通过 `class.getDeclaredField("value")` 获取指定参数：** `Field field = targetClass.getDeclaredField("value");`
6. **通过 `field.set(targetObject, "JavaGuide")` 进行参数修改：** `field.set(targetObject, "JavaGuide");`
7. **通过 `privateMethod.setAccessible(true)` & `field.setAccessible(true)` 取消安全检查（主要用于 private 方法与参数）**：`field.setAccessible(true);`

## 注解
`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。最常见的注解： `@Override`、`@Deprecated`。

注解只有被解析之后才会生效，常见的解析方法有两种：
- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

## Java 代理模式 ⭐
**使用代理对象来代替对真实对象(real object)的访问，在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**

代理模式有静态代理和动态代理两种实现方式：
- 静态代理：**对目标对象的每个方法的增强都是手动完成的，不灵活且麻烦。**（接口一旦新增加方法，目标对象和代理对象都要进行修改；需要对每个目标类都单独写一个代理类）-- 不常用，不用特别关注
- 动态代理：**动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。** 常见有 **JDK 动态代理**、**CGLIB 动态代理** 两种实现方式。

### JDK 动态代理机制
**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。** 通过实现 `InvocationHandler` 接口的 `invoke` 方法来自定义处理逻辑。通过 `Proxy` 类的 `newProxyInstance()` 方法来生成一个代理对象。

完整步骤：
1. 定义一个接口及其实现类（原对象实现）；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象。

### CGLIB 动态代理机制
**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。** **为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。** 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。通过 `Enhancer` 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

完整步骤：
1. 定义一个类（原对象实现）；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()` 创建代理类。

### 总结
**JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 JDK 动态代理效率更高。

静态代理和动态代理的对比：
1. **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

## SPI ⭐
SPI 即 Service Provider Interface，服务提供者的接口。专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。常见使用场景：Spring 框架、数据库加载驱动、日志接口。该功能让我们可以直接在 maven 中修改一下 pom 依赖就行，不用改代码。

![[Pasted image 20240709000722.png]]

**SPI 机制的具体实现本质是通过反射完成的**。即：**我们按照规定将要暴露对外使用的具体实现类在 `META-INF/services/` 文件下声明。**

SPI 机制依赖 `ServiceLoader` 实现，`ServiceLoader` 是 JDK 提供的一个工具类，位于 `package java.util;` 包下，它是 **一种加载服务实现的工具**。

主要的流程就是：
1. 通过 URL 工具类从 jar 包的 `/META-INF/services` 目录下面找到对应的文件，
2. 读取这个文件的名称找到对应的 spi 接口，
3. 通过 `InputStream` 流将文件里面的具体实现类的全类名读取出来，
4. 根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，
5. 将构造出来的实例对象添加到 `Providers` 的列表中。

## 序列化 & 反序列化
- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**
![[Pasted image 20240708224610.png]]

**序列化协议对应 TCP/IP 四层模型的应用层、OSI 七层协议模型的表示层。**
![[Pasted image 20240708224757.png]]

常见序列化协议有：JDK 自带、Hessian、Kryo、Protobuf、ProtoStuff。

## I/O
IO 即 `Input/Output`，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### Java IO 设计模式
#### 装饰器模式

#### 适配器模式

#### 工厂模式

#### 观察者模式

### Java IO 模型
#### 常见 IO 模型

#### BIO & NIO & AIO

## 语法糖 ⭐
**语法糖（Syntactic Sugar）** 指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

 **Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。**

常见语法糖：
- **switch 支持 String 与枚举：通过 `equals()` 和 `hashCode()` 方法实现。**
- **泛型：通过类型擦除（`type erasue`）实现。**
- **自动装箱与拆箱：装箱通过调用包装器的 valueOf 方法实现，拆箱通过调用包装器的 xxxValue 方法实现。**
- 可变长参数
- 枚举
- 内部类
- 条件编译
- **断言：底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行**。
- 数值字面量
- **for-each：for-each 的实现原理其实就是使用了普通的 for 循环和迭代器**。
- **try-with-resource：我们没有做的关闭资源的操作，编译器都帮我们做了**。
- **Lambda 表达式：lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式**。

# Java 并发
## 线程与进程 ⭐
进程是程序的一次执行过程，是系统运行程序的基本单位，系统运行一个程序即是一个进程从创建，运行到消亡的过程。一个进程中可以有多个线程，多个线程共享进程的 **堆** 和 **方法区 (JDK1.8 之后的元空间)** 资源，但是每个线程有自己的 **程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

程序计数器主要有下面两个作用：
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

虚拟机栈和本地方法栈为什么私有：
- **虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**
为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 线程生命周期
应用中一般通过继承 `Thread` 类、实现 `Runnable` 接口、实现 `Callable` 接口、使用线程池、使用 `CompletableFuture` 类等方式创建线程，实际这些方式最终都是通过 `new Thread().start()` 进行创建的。
![[Pasted image 20240709014536.png]]

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
这三种情况会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。频繁切换会造成整体效率低下。

## `Thread#sleep()` & `Object.wait()`
**共同点**：两者都可以暂停线程的执行。
**区别**：
- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
而 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁，因此定义在 `Thread` 中。

## 可以直接调用 Thread 类的 run 方法吗？ ⭐
new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。
直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

## 线程的类型和任务的性质
- **CPU 密集型**：CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。
- **IO 密集型**：IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

## 多线程带来的问题
并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

## 死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

使用 `jmap`、`jstack` 等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:` 的字样，后面会跟着死锁相关的线程信息。实际项目中还可以搭配使用 `top`、`df`、`free` 等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

通过破坏死锁的产生的必要条件**预防死锁**：
- **破坏请求与保持条件**：一次性申请所有的资源。
- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入**安全状态**。
>**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

## 虚拟线程

## JMM(Java 内存模型)

## `volatile`





# Java 集合

# JVM

# 设计模式

# IO
