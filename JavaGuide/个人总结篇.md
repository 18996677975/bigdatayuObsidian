# Java 基础
## JIT & AOT
 **JIT（Just in Time Compilation）** 编译器属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。
 ![[Pasted image 20240708213305.png]]

JDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。AOT 主要缺点在于无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。

## 基础类型与包装类型
- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- **比较方式**：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

Java 基本数据类型的包装类型使用缓存机制提升性能：`Byte`, `Short`, `Integer`, `Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。浮点数类型的包装类 `Float`, `Double` 并没有实现缓存机制。

**自动装箱与拆箱** 属于 **语法糖** 范畴：
- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型。

示例：
- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`

**频繁拆装箱会严重影响系统的性能，应避免不必要拆装箱操作。**

## 浮点数精度问题
浮点数存在精度丢失问题，与计算机保存浮点数的机制有关。计算机表示数字时，宽度有限，无限循环的小数存储在计算机时，只能被截断，因此导致小数精度发生损失的情况。

可通过 **`BigDecimal` 实现对浮点数的运算，不会造成精度丢失。**

用 `BigInteger` 可解决超过 long 整型的数据表示，它内部使用 `int[]` 数组来存储任意大小的整形数据，较常规数据类型运算效率更低。

## 重载与重写 ⭐
>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
\
 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

### 重载
发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。**

### 重写
重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

**方法的重写要遵循“两同两小一大”**：
- “两同” 即方法名相同、形参列表相同；
- “两小” 指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大” 指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

## 构造方法
构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。没有声明构造方法，也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。

构造方法特点：
- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

## 面向对象三特征 ⭐
### 封装
封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。可提供一些可以被外界访问的方法来操作属性（get、set）。
### 继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。（重写 @Override）

### 多态
多态，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

**多态的特点:**
- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用 “只在子类存在但在父类不存在” 的方法；
- 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 接口 & 抽象类
**共同点**：
- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别**：
- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但可以多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## 浅拷贝 & 深拷贝 & 引用拷贝
- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
- **引用拷贝**：两个不同的引用指向同一个对象。
![[Pasted image 20240625001148.png]]

## String & StringBuilder & StringBuffer
**可变性**
`String` 是不可变的。`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，`AbstractStringBuilder` 类提供了修改字符串的方法比如 `append` 方法。

**线程安全性**
`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，是线程安全的。`StringBuilder` 线程不安全。

**性能**
相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 能获得 10%~15% 左右的性能提升。

**使用总结**
- 操作少量的数据: 适用 `String`
- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

## Exception & Error
所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类：
- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`**：`Error` 属于程序无法处理的错误 ，不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

其中 **Exception** 又分为了 **Checked Exception** 与 **Unchecked Exception**：
- **Checked Exception** 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException` ……
- **Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中，我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常，常见的有：`NullPointerException` (空指针错误)、`IllegalArgumentException` (参数错误比如方法入参类型错误)、`NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException` 的子类）、`ArrayIndexOutOfBoundsException`（数组越界错误）……

##  `try-with-resources` 代替 `try-catch-finally`
`try-with-resources` 也是一种语法糖。

- **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象
- **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

`try-with-resources` 语句让我们更容易编写必须要关闭的资源的代码，更简短，更清晰，产生的异常对我们也更有用。

## Java 值传递
Java 中将实参传递给方法（或函数）的方式是 **值传递**：
- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 泛型 & 通配符 ⭐
### 泛型
泛型也是一种语法糖，于 Java 5 引入。使用泛型参数，可以 **增强代码的可读性以及稳定性**。编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。并且泛型可以让编译器自动转换类型。

泛型一般有三种使用方式：**泛型类**、**泛型接口**、**泛型方法**。
**1. 泛型类**：
```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```
如何实例化泛型类：
```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```
**2. 泛型接口**：
```java
public interface Generator<T> {
    public T method();
}
```
实现泛型接口，不指定类型：
```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```
实现泛型接口，指定类型：
```java
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```
**3. 泛型方法**：
```java
public static < E > void printArray( E[] inputArray )
{
      for ( E element : inputArray ){
         System.out.printf( "%s ", element );
      }
      System.out.println();
 }
```
使用：
```java
// 创建不同类型数组：Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray( intArray  );
printArray( stringArray  );
```

使用泛型的场景：
- 自定义接口通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）
- ……

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。对于 Java 虚拟机来说，他根本不认识 `Map<String, String> map` 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。

类型擦除的主要过程如下：1. 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2. 移除所有的类型参数。
以下代码：
```java
Map<String, String> map = new HashMap<String, String>();
```
解语法糖之后会变成：
```java
Map map = new HashMap();
```
以下代码：
```java
public static <A extends Comparable<A>> A max(Collection<A> xs) {
    Iterator<A> xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) < 0)
            w = x;
    }
    return w;
}
```
类型擦除后会变成：
```java
public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) < 0)
            w = x;
    }
    return w;
}
```

### 通配符
泛型通配符（Wildcard）是一种特殊的类型参数，用于表示未知类型或不确定类型。在 Java 中，有三种泛型通配符（分为限定通配符与非限定通配符）：
- `?`：表示任意类型。（非限定通配符）
- `? extends T`：表示某个类的子类或该类本身。（限定通配符）
- `? super T`：表示某个类的父类或该类本身。（限定通配符）

`<? extends T>` 它通过确保类型必须是 T 的子类来设定类型的上界，`<? super T>` 它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。

通过使用泛型通配符，我们可以编写更加灵活和通用的代码，使得方法能够接受多种类型的参数。

### 总结
泛型是 Java 中一种强大的特性，通过使用泛型，我们可以编写**更加通用、灵活和类型安全的代码**。**泛型通配符则进一步增强了代码的灵活性和重用性，使得方法能够接受多种类型的参数**。然而，过度使用泛型和通配符可能会导致代码复杂化，需要根据实际情况进行权衡和选择。

优点：
- 增强代码的可读性和可维护性：通过使用泛型和通配符，我们可以编写更加通用和灵活的代码，提高代码的重用性和可扩展性。
- 提供类型安全性：泛型在编译时进行类型检查，避免了运行时的类型转换异常，增强了代码的健壮性。
- 支持多态性：通过使用通配符，我们可以实现对不同类型的对象进行操作，提高了代码的灵活性和适应性。

缺点：
- 无法获取具体的泛型类型信息：由于类型擦除的原因，无法在运行时获取到具体的泛型类型信息，这可能会限制一些特定的操作。
- 可能导致代码复杂化：过度使用泛型和通配符可能会导致代码变得复杂难懂，增加了学习成本和调试困难。

注意事项：
- 在定义泛型方法时，可以使用 `<T>` 来表示类型参数。
- 使用通配符时，需要注意通配符的上限和下限，以确保代码的正确性和安全性。
- 需要根据具体的业务需求和场景选择合适的泛型和通配符使用方式。

## 反射 ⭐
Spring/Spring Boot、MyBatis 等框架大量使用了反射机制。**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。** **注解** 的实现也用到了反射。

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利，让我们在运行时有了分析操作类的能力。

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。

**反射实战**

获取 class 对象方法：
1. **知道具体类的情况下可使用**：`Class alunbarClass = TargetObject.class;`
2. **通过 `Class.forName()` 传入类的全路径获取：** `Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`
3. **通过对象实例 `instance.getClass()` 获取：** `TargetObject o = new TargetObject();Class alunbarClass2 = o.getClass();`
4. **通过类加载器 `xxxClassLoader.loadClass()` 传入类路径获取（类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行）：** `ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");`

然后通过如下方式进行操作：
1. **通过 `class.newInstance()` 创建实例：** `TargetObject targetObject = (TargetObject) targetClass.newInstance();`
2. **通过 `class.getDeclaredMethods()` 获取定义的方法：** `Method[] methods = targetClass.getDeclaredMethods();`
3. **通过 `class.getDeclaredMethod("publicMethod", String.class)` 获取特定方法：** `Method publicMethod = targetClass.getDeclaredMethod("publicMethod", String.class);`
4. **通过 `method.invoke(object, args)` 进行方法调用：** `publicMethod.invoke(targetObject, "JavaGuide");`
5. **通过 `class.getDeclaredField("value")` 获取指定参数：** `Field field = targetClass.getDeclaredField("value");`
6. **通过 `field.set(targetObject, "JavaGuide")` 进行参数修改：** `field.set(targetObject, "JavaGuide");`
7. **通过 `privateMethod.setAccessible(true)` & `field.setAccessible(true)` 取消安全检查（主要用于 private 方法与参数）**：`field.setAccessible(true);`

## 注解
`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。最常见的注解： `@Override`、`@Deprecated`。

注解只有被解析之后才会生效，常见的解析方法有两种：
- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

## Java 代理模式 ⭐
**使用代理对象来代替对真实对象(real object)的访问，在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**

代理模式有静态代理和动态代理两种实现方式：
- 静态代理：**对目标对象的每个方法的增强都是手动完成的，不灵活且麻烦。**（接口一旦新增加方法，目标对象和代理对象都要进行修改；需要对每个目标类都单独写一个代理类）-- 不常用，不用特别关注
- 动态代理：**动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。** 常见有 **JDK 动态代理**、**CGLIB 动态代理** 两种实现方式。

### JDK 动态代理机制
**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。** 通过实现 `InvocationHandler` 接口的 `invoke` 方法来自定义处理逻辑。通过 `Proxy` 类的 `newProxyInstance()` 方法来生成一个代理对象。

完整步骤：
1. 定义一个接口及其实现类（原对象实现）；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象。

### CGLIB 动态代理机制
**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。** **为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。** 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。通过 `Enhancer` 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

完整步骤：
1. 定义一个类（原对象实现）；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()` 创建代理类。

### 总结
**JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 JDK 动态代理效率更高。

静态代理和动态代理的对比：
1. **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

## SPI ⭐
SPI 即 Service Provider Interface，服务提供者的接口。专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。常见使用场景：Spring 框架、数据库加载驱动、日志接口。该功能让我们可以直接在 maven 中修改一下 pom 依赖就行，不用改代码。

![[Pasted image 20240709000722.png]]

**SPI 机制的具体实现本质是通过反射完成的**。即：**我们按照规定将要暴露对外使用的具体实现类在 `META-INF/services/` 文件下声明。**

SPI 机制依赖 `ServiceLoader` 实现，`ServiceLoader` 是 JDK 提供的一个工具类，位于 `package java.util;` 包下，它是 **一种加载服务实现的工具**。

主要的流程就是：
1. 通过 URL 工具类从 jar 包的 `/META-INF/services` 目录下面找到对应的文件，
2. 读取这个文件的名称找到对应的 spi 接口，
3. 通过 `InputStream` 流将文件里面的具体实现类的全类名读取出来，
4. 根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，
5. 将构造出来的实例对象添加到 `Providers` 的列表中。

## 序列化 & 反序列化
- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**
![[Pasted image 20240708224610.png]]

**序列化协议对应 TCP/IP 四层模型的应用层、OSI 七层协议模型的表示层。**
![[Pasted image 20240708224757.png]]

常见序列化协议有：JDK 自带、Hessian、Kryo、Protobuf、ProtoStuff。

## I/O
IO 即 `Input/Output`，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### Java IO 设计模式
#### 装饰器模式

#### 适配器模式

#### 工厂模式

#### 观察者模式

### Java IO 模型
#### 常见 IO 模型

#### BIO & NIO & AIO

## 语法糖 ⭐
**语法糖（Syntactic Sugar）** 指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

 **Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。**

常见语法糖：
- **switch 支持 String 与枚举：通过 `equals()` 和 `hashCode()` 方法实现。**
- **泛型：通过类型擦除（`type erasue`）实现。**
- **自动装箱与拆箱：装箱通过调用包装器的 valueOf 方法实现，拆箱通过调用包装器的 xxxValue 方法实现。**
- 可变长参数
- 枚举
- 内部类
- 条件编译
- **断言：底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行**。
- 数值字面量
- **for-each：for-each 的实现原理其实就是使用了普通的 for 循环和迭代器**。
- **try-with-resource：我们没有做的关闭资源的操作，编译器都帮我们做了**。
- **Lambda 表达式：lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式**。

# Java 并发
## 线程与进程 ⭐
进程是程序的一次执行过程，是系统运行程序的基本单位，系统运行一个程序即是一个进程从创建，运行到消亡的过程。一个进程中可以有多个线程，多个线程共享进程的 **堆** 和 **方法区 (JDK1.8 之后的元空间)** 资源，但是每个线程有自己的 **程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

程序计数器主要有下面两个作用：
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

虚拟机栈和本地方法栈为什么私有：
- **虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 线程生命周期
应用中一般通过继承 `Thread` 类、实现 `Runnable` 接口、实现 `Callable` 接口、使用线程池、使用 `CompletableFuture` 类等方式创建线程，实际这些方式最终都是通过 `new Thread().start()` 进行创建的。
![[Pasted image 20240709014536.png]]

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
这三种情况会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。频繁切换会造成整体效率低下。

## `Thread#sleep()` & `Object.wait()`
**共同点**：两者都可以暂停线程的执行。
**区别**：
- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
而 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁，因此定义在 `Thread` 中。

## 可以直接调用 Thread 类的 run 方法吗？ ⭐
new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。
直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

## 线程的类型和任务的性质
- **CPU 密集型**：CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。
- **IO 密集型**：IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

## 多线程带来的问题
并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

## 死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

使用 `jmap`、`jstack` 等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:` 的字样，后面会跟着死锁相关的线程信息。实际项目中还可以搭配使用 `top`、`df`、`free` 等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

通过破坏死锁的产生的必要条件**预防死锁**：
- **破坏请求与保持条件**：一次性申请所有的资源。
- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入**安全状态**。
>**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

## 虚拟线程

## JMM(Java 内存模型) ⭐
**缓存模型：CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。**
**CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 [MESI 协议](https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE)）或者其他手段来解决。**

**指令重排序：为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。** 注意：**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。（通过 **内存屏障** 禁止处理器重排序，`volatile` 底层实际也是通过 **内存屏障** 实现的禁止重排序）

**JMM 可看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。** JSR 133 引入了 **happens-before** 这个概念来描述**两个操作之间的内存可见性**。

Java 内存区域与 JMM：
- JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
- Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

**happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。**

## 并发编程三特性 ⭐
### 原子性
一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。借助`synchronized`、各种 `Lock` 以及各种原子类实现原子性。`synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 `volatile`或者`final`关键字）来保证原子操作。
### 可见性
当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。在 Java 中，可以借助`synchronized`、`volatile` 以及各种 `Lock` 实现可见性。如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
### 有序性
由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化。

## `volatile` ⭐
将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

**在 Java 中，`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。** 如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。

**双重校验锁实现对象单例（线程安全）**：
```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
**`volatile` 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。**

## 乐观锁 & 悲观锁 ⭐
**悲观锁**：每次在获取资源操作的时候都会上锁，其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。`synchronized` 和 `ReentrantLock` 等独占锁就是悲观锁思想的实现。

**乐观锁**：认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用**版本号机制**或 **CAS 算法**，CAS 算法更常见）。`java.util.concurrent.atomic` 包下面的原子变量类（比如 `AtomicInteger`、`LongAdder`）就是使用了乐观锁的一种实现方式 **CAS** 实现的。

**版本号机制**：在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。

**CAS 算法**：CAS 的全称是 **Compare And Swap（比较与交换）** ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。

**悲观锁&乐观锁对比**：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。

**CAS 算法的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。**
- 通过变量前面追加上 **版本号或者时间戳** 的方式解决 **ABA** 问题，Java 中使用 `AtomicStampedReference` 类解决 **ABA** 问题。
- CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。
- CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。从 JDK 1.5 开始，提供了 `AtomicReference` 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作，可使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作。

## `synchronized` ⭐
解决多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

**`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。**
**不过两者的本质都是对对象监视器 monitor 的获取。**

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在：
- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

## ReentrantLock ⭐
`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

**ReentrantLock & synchronized**：
- 都是可重入锁
- `synchronized` 依赖于 JVM，ReentrantLock 依赖于 API
- ReentrantLock 多了一些高级功能
	- **等待可中断**：`ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
	- **公平锁**：`ReentrantLock`可以指定是公平锁还是非公平锁。`synchronized`只能是非公平锁。
	- **选择性通知**：`synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

可中断锁 & 不可中断锁区别：
- **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。

## Atomic 原子类 ⭐
主要利用 **CAS (compare and swap)** + **volatile** 和 **native** 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。是 **乐观锁** 实现的一种体现。

**基本类型**
使用原子的方式更新基本类型
- `AtomicInteger`：整型原子类
- `AtomicLong`：长整型原子类
- `AtomicBoolean`：布尔型原子类

**数组类型**
使用原子的方式更新数组里的某个元素
- `AtomicIntegerArray`：整型数组原子类
- `AtomicLongArray`：长整型数组原子类
- `AtomicReferenceArray`：引用类型数组原子类

**引用类型**
- `AtomicReference`：引用类型原子类
- `AtomicMarkableReference`：原子更新带有标记的引用类型。
- `AtomicStampedReference`：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

## ThreadLocal ⭐
`ThreadLocal` 对象可以提供线程局部变量，每个线程 `Thread` 拥有一份自己的**副本变量**，多个线程互不干扰。

**每个 `Thread` 中都具备一个 `ThreadLocalMap`，而 `ThreadLocalMap` 可以存储以 `ThreadLocal` 为 key ，Object 对象为 value 的键值对。**
 **最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。** `ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**`ThreadLocal` 内存泄露：**
`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。

`ThreadLocalMap` 的两种过期 `key` 数据清理方式：**探测式清理**和**启发式清理**。
在 `set()` 、`get()`、`remove()` 操作时，遇到 key 为 null 的记录会自动触发清理操作。使用完 `ThreadLocal` 方法后最好手动调用 `remove()` 方法，以防出现内存泄露问题。

## 线程池 ⭐
- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 线程池创建方式
**方式一：通过 `ThreadPoolExecutor` 构造函数来创建**。

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建。**（不推荐）
`Executors` 工具类提供四种类型线程池：
- `FixedThreadPool`：固定线程数量的线程池。无边界队列，OOM 风险。
- `SingleThreadExecutor`： 只有一个线程的线程池。无边界队列，OOM 风险。
- `CachedThreadPool`： 可根据实际情况调整线程数量的线程池。无边界线程数，OOM 风险。
- `ScheduledThreadPool`：给定的延迟后运行任务或者定期执行任务的线程池。无边界延迟阻塞队列，OOM 风险。
### 线程池常见参数
- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
- `keepAliveTime`：线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime` 才会被回收销毁。
- `unit` : `keepAliveTime` 参数的时间单位。
- `threadFactory`：executor 创建新线程的时候会用到。
- `handler`：拒绝策略：
	- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException` 来拒绝新任务的处理。
	- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
	- `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
	- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。

### 线程池处理任务流程
![[Pasted image 20240709154306.png]]
### 线程池中线程异常后，销毁还是复用？
- **使用`execute()`提交任务**：当任务通过`execute()`提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。
- **使用`submit()`提交任务**：对于通过`submit()`提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由`submit()`返回的`Future`对象中。当调用`Future.get()`方法时，可以捕获到一个`ExecutionException`。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。

简单来说：使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；使用`submit()`时，异常被封装在`Future`中，线程继续复用。

## Future ⭐
`Future` 类是异步思想的典型运用。当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 `Future` 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。

`Future` 类只是一个泛型接口，主要包括下面这 4 个功能：
- 取消任务；
- 判断任务是否被取消；
- 判断任务是否已经执行完成；
- 获取任务执行结果。

`Future` 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 `get()` 方法为阻塞调用。Java 8 引入`CompletableFuture` 类可以解决`Future` 的这些缺陷。`CompletableFuture` 除了提供了更为好用和强大的 `Future` 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。

## AQS ⭐
AQS 的全称为 `AbstractQueuedSynchronizer` ，抽象队列同步器。AQS 就是一个抽象类，主要用来构建锁和同步器。
AQS 为**构建锁和同步器提供了一些通用功能的实现**，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 **CLH 队列锁** 实现的，即将暂时获取不到锁的线程加入到队列中。
![[Pasted image 20240709155311.png]]

AQS 使用 **int 成员变量 `state` 表示同步状态**，通过内置的 **线程等待队列** 来完成获取资源线程的排队工作。`state` 变量由 `volatile` 修饰，用于展示当前临界资源的获锁情况。

以 `ReentrantLock` 为例，`state` 初始值为 0，表示未锁定状态。A 线程 `lock()` 时，会调用 `tryAcquire()` 独占该锁并将 `state+1` 。此后，其他线程再 `tryAcquire()` 时就会失败，直到 A 线程 `unlock()` 到 `state=`0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（`state` 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。

再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，`state` 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后`countDown()` 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 `state=0` )，会 `unpark()` 主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作。

# Java 集合

# JVM
## Java 内存区域
![[Pasted image 20240709160128.png]]
**线程私有的：**
- 程序计数器
- 虚拟机栈
- 本地方法栈
**线程共享的：**
- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

直接内存：直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。**NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）** 与 **缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为 **避免了在 Java 堆和 Native 堆之间来回复制数据**。

## 对象的创建
1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 分配内存：**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
3. 初始化零值：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. 设置对象头：初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
5. 执行 init 方法：执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

**内存分配的两种方式** （补充内容，需要掌握）：
- 指针碰撞：
    - 适用场合：堆内存规整（即没有内存碎片）的情况下。
    - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：
    - 适用场合：堆内存不规整的情况下。
    - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**
在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）** 和 **对齐填充（Padding）**。

## JVM 垃圾回收
堆内存被通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)
![[Pasted image 20240709161106.png]]
### 内存分配与回收原则
- 对象优先在 Eden 区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代：新生代中每进行一次 Minor GC 对象 Age+1，>15 进入老年代
- 主要进行 gc 的区域：
	- 部分收集(Partial GC)：
		- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
		- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
		- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
	- 整堆收集 (Full GC)：收集整个 Java 堆和方法区。
- 空间分配担保：为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。
### 死亡对象判断
**可达性分析算法**：

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**可作为 GC Roots 的对象**：
- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

**两次不可达才会进行回收。**
### 垃圾回收算法
- 标记-清除算法：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。
- 复制算法：内存分块，单块使用完毕，将存活对象复制到另一块，然后把使用的空间一次清理掉。
- 标记-整理算法：首先标记出所有不需要回收的对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代收集算法：根据各个年代的特点选择合适的垃圾收集算法。新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
### 垃圾回收器
**收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。**
#### Parallel Scavenge 收集器 + Parallel Old 收集器
JDK 8 默认垃圾回收器
![[Pasted image 20240709163407.png]]
#### CMS 收集器
**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。** 整个过程分为四个步骤：
- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
![[Pasted image 20240709163519.png]]
缺点：
- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
#### G1 收集器
**JDK 9 后的默认垃圾收集器。G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。**

特点：
- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
![[Pasted image 20240709163715.png]]
**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

## 类加载器
### 类加载过程
- 类加载过程：**加载->连接->初始化**。
- 连接过程又可分为三步：**验证->准备->解析**。
### 类加载器
**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
- **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

### 双亲委派模型
双亲委派模型是 Java 类加载机制中的一种重要设计模式。

当一个类需要被加载时，它不会直接由当前类加载器去尝试加载，而是先委托给父类加载器去加载。如果父类加载器无法加载，再由当前类加载器去尝试加载。

**好处包括**：
1. **保证安全性**：可以防止用户自己编写的类替换掉核心的 Java API 类。例如，如果没有双亲委派模型，用户可以自定义一个 `java.lang.String` 类并加载，这可能会导致严重的安全问题。
2. **避免类的重复加载**：父类加载器加载过的类，子类加载器无需再次加载，节省了系统资源。例如，如果多个类加载器都去加载同一个类，会造成内存的浪费和性能的下降。
3. **保证类的唯一性**：确保一个类在 JVM 中只有一个定义，避免了类的混乱和冲突。设想在一个复杂的应用中，如果不同的类加载器加载了同名但不同实现的类，可能会导致程序运行时出现不可预测的错误。

**执行流程：**
- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

# 设计模式
## 设计模式简介
Java 中有 23 种经典的设计模式，分为三大类：创建型模式、结构型模式和行为型模式。以下是每种模式的简要介绍：

### 创建型模式
1. **单例模式**：确保一个类只有一个实例，并提供一个全局访问点。
2. **抽象工厂模式**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
3. **建造者模式**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
4. **工厂方法模式**：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。
5. **原型模式**：通过复制现有的实例来创建新的对象，而不是通过实例化类。

### 结构型模式
1. **适配器模式**：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。
2. **桥接模式**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
3. **装饰模式**：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
4. **组合模式**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
5. **外观模式**：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用。
6. **享元模式**：运用共享技术有效地支持大量细粒度的对象。
7. **代理模式**：为其他对象提供一种代理以控制对这个对象的访问。

### 行为型模式
1. **模版方法模式**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法结构即可重定义该算法的某些特定步骤。
2. **命令模式**：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
3. **迭代器模式**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
4. **观察者模式**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
5. **中介者模式**：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
6. **备忘录模式**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复对象到原先保存的状态。
7. **解释器模式**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
8. **状态模式**：允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类。
9. **策略模式**：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换，本模式使得算法可独立于使用它的客户而变化。
10. **责任链模式**：为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
11. **访问者模式**：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

这些设计模式可以帮助你编写更灵活、可维护和可扩展的代码。

## 常考查的设计模式
在 Java 面试中，常见的设计模式考察包括以下几种：

### 创建型模式
1. **单例模式**：确保一个类只有一个实例，并提供一个全局访问点。面试中常被问到如何实现线程安全的单例模式。
2. **工厂方法模式**：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。面试中可能会要求你手写代码实现。
3. **抽象工厂模式**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 结构型模式
1. **代理模式**：为其他对象提供一种代理以控制对这个对象的访问。面试中可能会问到静态代理和动态代理的区别。
2. **装饰模式**：动态地给一个对象添加一些额外的职责。面试中可能会要求你解释如何使用装饰模式来扩展类的功能。
3. **适配器模式**：将一个类的接口转换成客户希望的另一个接口。面试中可能会问到实际应用场景。

### 行为型模式
1. **观察者模式**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。面试中常被问到在实际项目中的应用。
2. **策略模式**：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。面试中可能会要求你举例说明。
3. **责任链模式**：为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。面试中可能会问到如何实现责任链模式。

## 实操案例：
当然有！以下是一些 Java 设计模式在实际项目中的应用案例：

### 单例模式
**应用场景**：数据库连接池、日志记录器、配置管理器等。 **案例**：在一个 web 应用中，使用单例模式来管理数据库连接池，确保应用程序中只有一个数据库连接池实例，从而提高资源利用率和性能。

### 工厂方法模式
**应用场景**：创建复杂对象时，避免直接使用 new 关键字。 **案例**：在一个电商平台中，使用工厂方法模式来创建不同类型的支付方式（如信用卡支付、支付宝支付、微信支付），根据用户选择动态生成相应的支付对象。

### 代理模式
**应用场景**：控制对对象的访问、延迟加载、日志记录等。 **案例**：在一个安全系统中，使用代理模式来控制对敏感数据的访问，只有经过身份验证的用户才能访问数据。

### 观察者模式
**应用场景**：事件驱动系统、通知系统等。 **案例**：在一个社交媒体应用中，使用观察者模式来实现用户关注功能，当用户发布新动态时，所有关注他的用户都会收到通知。

### 策略模式
**应用场景**：算法的动态选择、行为的动态改变等。 **案例**：在一个推荐系统中，使用策略模式来动态选择不同的推荐算法（如基于内容的推荐、协同过滤推荐），根据用户的行为和偏好调整推荐策略。

### 责任链模式
**应用场景**：请求的处理链、日志处理等。 **案例**：在一个请求处理系统中，使用责任链模式来处理用户请求，不同的处理器（如认证处理器、权限处理器、业务处理器）按顺序处理请求，直到请求被完全处理。

# IO
