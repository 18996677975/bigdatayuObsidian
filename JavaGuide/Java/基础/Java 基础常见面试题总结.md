## 基础概念与常识
### JVM & JDK & JRE
#### JVM
Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言 “一次编译，随处可以运行” 的关键所在。
![[Pasted image 20240621172330.png|625]]
**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。**
#### JDK 和 JRE
JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。
JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。
也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。
![[Pasted image 20240621172430.png|550]]
从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。

### 字节码
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。
**Java 程序从源代码到运行的过程如下图所示**：
![[Pasted image 20240621173948.png|550]]
我们需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 **JIT（Just in Time Compilation）** 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。
![[Pasted image 20240621174016.png|550]]
> HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。

JDK、JRE、JVM、JIT 这四者的关系如下图所示。
![[Pasted image 20240621174122.png]]
下面这张图是 JVM 的大致结构模型。
![[Pasted image 20240621174134.png|500]]

### AOT 是什么？有什么优点？为什么不全用 AOT？
JDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。
**JIT 与 AOT 两者的关键指标对比**:
![[Pasted image 20240621174215.png|550]]
可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。
**既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？**
我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。

## 基本语法
### 标识符与关键字

### 移位运算符

## 基本数据类型
### 基本数据类型有哪些

### 基本类型与包装类型的区别

### 包装类型的缓存机制

### 自动装箱与拆箱

### 浮点数运算精度丢失风险与解决方法

### 超 long 整型数据表示方法

## 变量
### 成员变量与局部变量区别

### 静态变量作用

### 字符型常量与字符串常量区别

## 方法
### 什么是返回值？方法的类型？

### 静态方法不可调用非静态变量原因

### 静态方法与实例方法区别

### 重载与重写

### 可变长参数

## 面向对象基础
### 面向对象与面向过程的区别

### 面向对象三大特征

### 如何创建对象？对象实体与对象引用的区别

### 对象相等与引用相等的区别

### 构造方法特点、能否被 override、无声明构造方法的类能否正常执行

### 接口与抽象类

### 深拷贝、浅拷贝、引用拷贝

## Object
### 常见方法

### == 与 equals() 区别

### 方法 hashCode() 作用

### 重写 equals 需重写 hashCode 方法原因

## String
### String、StringBuffer、StringBuilder

### String 不可变特性

### 字符串拼接用“+”还是用 StringBuilder

### String.Equals 与 Object.Equals 区别

### 字符串常量池作用

### String s1 = new String("abc");这句话创建了几个字符串对象？

### String.intern 方法有什么作用?

### String 类型的变量和常量做“+”运算时发生了什么？

## 异常
![[Pasted image 20240617164658.png|500]]
### Exception 和 Error 区别

### Checked Exception 和 UNChecked Exception 区别

### Throwable 常用方法

### Try-catch-finally 使用方法，finally 中的代码一定会执行吗？

### Try-with-resource

### 异常使用注意事项

## 泛型
### 泛型定义与作用

### 泛型使用方式，常见使用案例

## 反射
### 反射定义与优缺点

### 反射的应用场景

## 注解
### 注解定义

### 注解的解析方法

## SPI
### SPI 定义与优缺点

### SPI 与 API 区别

## 序列化与反序列化
### 序列化与反序列化定义

### 常见序列化协议

### 对特定变量不进行序列化的方式

### 不推荐使用 JKD 自动序列化的原因

## I/O
### Java IO 流是什么

### IO 流分为字节流与字符流原因

### Java IO 设计模式有哪些

### BIO、NIO、AIO 区别

## 语法糖
### 语法糖定义

### Java 常见语法糖