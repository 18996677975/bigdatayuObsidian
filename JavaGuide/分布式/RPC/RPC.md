# RPC 定义
**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。

**为什么要 RPC ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。

**RPC 能帮助我们做什么呢？** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。

举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

# RPC 原理
为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：

1. **客户端（服务消费端）**：调用远程方法的一端。
2. **客户端 Stub（桩）**：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
3. **网络传输**：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。
4. **服务端 Stub（桩）**：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。
5. **服务端（服务提供端）**：提供远程方法的一端。

具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。
![[Pasted image 20240723003321.png]]

1. 服务消费端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:`RpcResponse` ，这样也就得到了最终结果。over!

相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。

虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。

**最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。**

# 有哪些常见的 RPC 框架？
我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC 这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如 Feign。

## Dubbo
## Motan
## gRPC
## Thrift

## 总结
gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。

Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo 在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。

下图展示了 Dubbo 的生态系统。
![[Pasted image 20240723003425.png]]

Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。
![[Pasted image 20240723003436.png]]

但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。

综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。

# 如何设计并实现一个 RPC 框架？
设计并实现一个 RPC 框架通常包括以下几个主要部分：

1. **服务定义与接口描述**：
    - 定义服务提供的接口和方法，通常使用某种接口定义语言（IDL），如 Protocol Buffers、Thrift 等。
2. **序列化与反序列化**：
    - 选择高效的序列化方式，如 JSON、Protobuf 等，将方法调用的参数和返回值进行序列化和反序列化，以便在网络中传输。
3. **网络通信**：
    - 选择合适的网络协议，如 TCP 或 HTTP。
    - 建立连接、发送和接收数据。
4. **客户端与服务端**：
    - 客户端：负责将方法调用封装成请求，并通过网络发送给服务端。
    - 服务端：接收请求，解析参数，调用本地服务实现，将结果返回给客户端。
5. **服务注册与发现**：
    - 服务端需要将提供的服务注册到注册中心。
    - 客户端从注册中心获取可用的服务地址列表。
6. **负载均衡**：
    - 客户端在调用服务时，根据一定的策略选择一个合适的服务端实例，如随机、轮询、加权等。
7. **异常处理**：
    - 处理网络异常、服务端错误等情况，将异常信息传递给调用方。
8. **监控与日志**：
    - 记录 RPC 调用的相关信息，如调用时间、调用参数、返回结果等，以便进行监控和问题排查。

# 既然有了 HTTP 协议，为什么还要有 RPC ？
虽然 HTTP 协议被广泛使用，但仍然需要 RPC 主要有以下原因：

1. **性能和效率**：
    - RPC 通常可以使用更高效的序列化和反序列化方式，例如 Protocol Buffers、Thrift 等，相比 HTTP 常用的 JSON 或 XML 格式，数据传输量更小，解析速度更快。
    - RPC 可以基于更底层的网络协议，如 TCP，减少了 HTTP 协议中的一些额外开销，如请求头的处理。
2. **强类型和接口定义**：
    - RPC 框架通常支持更严格的接口定义和类型检查。在开发阶段就能发现类型不匹配等问题，提高代码的可靠性。
3. **服务治理**：
    - RPC 框架往往提供了更丰富的服务治理功能，如服务注册与发现、负载均衡、熔断、限流等。
4. **语言特定的支持**：
    - 许多 RPC 框架对特定编程语言提供了更友好的支持，能够更好地与该语言的特性和编程模型集成。
5. **灵活的通信模式**：
    - 除了常见的请求 - 响应模式，RPC 还可以支持双向通信、流式通信等更灵活的模式，满足不同场景的需求。

例如，在一个高并发、对性能要求苛刻的金融交易系统中，RPC 的高效数据传输和强类型支持可以确保交易处理的快速和准确；而在一个微服务架构的复杂系统中，RPC 框架提供的服务治理功能能够更好地管理众多的服务之间的调用关系。

总之，虽然 HTTP 具有通用性和简单性，但在一些对性能、服务治理和特定语言集成有更高要求的场景中，RPC 能够提供更优的解决方案。

